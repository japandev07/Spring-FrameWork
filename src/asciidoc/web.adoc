[[spring-web]]
= The Web

[partintro]
--
This part of the reference documentation covers Spring Framework's support for the
presentation tier (and specifically web-based presentation tiers) including support
for WebSocket-style messaging in web applications.

Spring Framework's own web framework, <<mvc,Spring Web MVC>>, is covered in the
first couple of chapters. Subsequent chapters are concerned with Spring Framework's
integration with other web technologies, such as <<jsf,JSF>> and.

Following that is coverage of Spring Framework's MVC <<portlet,portlet framework>>.

The section then concludes with comprehensive coverage of the Spring Framework
<<websocket>> (including <<websocket-stomp>>).

* <<mvc>>
* <<view>>
* <<web-integration>>
* <<portlet>>
* <<websocket>>
--

include::web-mvc.adoc[leveloffset=+1]

include::web-view.adoc[leveloffset=+1]

[[web-integration]]
== Integrating with other web frameworks


[[intro]]
=== Introduction

.Spring Web Flow
****
Spring Web Flow (SWF) aims to be the best solution for the management of web application
page flow.

SWF integrates with existing frameworks like Spring MVC and JSF, in both Servlet and
Portlet environments. If you have a business process (or processes) that would benefit
from a conversational model as opposed to a purely request model, then SWF may be the
solution.

SWF allows you to capture logical page flows as self-contained modules that are reusable
in different situations, and as such is ideal for building web application modules that
guide the user through controlled navigations that drive business processes.

For more information about SWF, consult the
http://projects.spring.io/spring-webflow/[Spring Web Flow website].
****

This chapter details Spring's integration with third party web frameworks, such as
http://www.oracle.com/technetwork/java/javaee/javaserverfaces-139869.html[JSF].

One of the core value propositions of the Spring Framework is that of enabling
__choice__. In a general sense, Spring does not force one to use or buy into any
particular architecture, technology, or methodology (although it certainly recommends
some over others). This freedom to pick and choose the architecture, technology, or
methodology that is most relevant to a developer and their development team is
arguably most evident in the web area, where Spring provides its own web framework
(<<mvc,Spring MVC>>), while at the same time providing integration with a number of
popular third party web frameworks. This allows one to continue to leverage any and all
of the skills one may have acquired in a particular web framework such as JSF, while
at the same time being able to enjoy the benefits afforded by Spring in other areas such
as data access, declarative transaction management, and flexible configuration and
application assembly.

Having dispensed with the woolly sales patter (c.f. the previous paragraph), the
remainder of this chapter will concentrate upon the meaty details of integrating your
favorite web framework with Spring. One thing that is often commented upon by developers
coming to Java from other languages is the seeming super-abundance of web frameworks
available in Java. There are indeed a great number of web frameworks in the Java space;
in fact there are far too many to cover with any semblance of detail in a single
chapter. This chapter thus picks four of the more popular web frameworks in Java,
starting with the Spring configuration that is common to all of the supported web
frameworks, and then detailing the specific integration options for each supported web
framework.

[NOTE]
====
Please note that this chapter does not attempt to explain how to use any of the
supported web frameworks. For example, if you want to use JSF for the presentation
layer of your web application, the assumption is that you are already familiar with
JSF itself. If you need further details about any of the supported web frameworks
themselves, please do consult <<web-integration-resources>> at the end of this chapter.
====




[[web-integration-common]]
=== Common configuration
Before diving into the integration specifics of each supported web framework, let us
first take a look at the Spring configuration that is __not__ specific to any one web
framework. (This section is equally applicable to Spring's own web framework, Spring
MVC.)

One of the concepts (for want of a better word) espoused by (Spring's) lightweight
application model is that of a layered architecture. Remember that in a 'classic'
layered architecture, the web layer is but one of many layers; it serves as one of the
entry points into a server side application and it delegates to service objects
(facades) defined in a service layer to satisfy business specific (and
presentation-technology agnostic) use cases. In Spring, these service objects, any other
business-specific objects, data access objects, etc. exist in a distinct 'business
context', which contains __no__ web or presentation layer objects (presentation objects
such as Spring MVC controllers are typically configured in a distinct 'presentation
context'). This section details how one configures a Spring container (a
`WebApplicationContext`) that contains all of the 'business beans' in one's application.

On to specifics: all that one need do is to declare a
{javadoc-baseurl}/org/springframework/web/context/ContextLoaderListener.html[`ContextLoaderListener`]
in the standard Java EE servlet `web.xml` file of one's web application, and add a
`contextConfigLocation`<context-param/> section (in the same file) that defines which
set of Spring XML configuration files to load.

Find below the <listener/> configuration:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>
----

Find below the <context-param/> configuration:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/applicationContext*.xml</param-value>
	</context-param>
----

If you don't specify the `contextConfigLocation` context parameter, the
`ContextLoaderListener` will look for a file called `/WEB-INF/applicationContext.xml` to
load. Once the context files are loaded, Spring creates a
{javadoc-baseurl}/org/springframework/web/context/WebApplicationContext.html[`WebApplicationContext`]
object based on the bean definitions and stores it in the `ServletContext` of the web
application.

All Java web frameworks are built on top of the Servlet API, and so one can use the
following code snippet to get access to this 'business context' `ApplicationContext`
created by the `ContextLoaderListener`.

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	WebApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(servletContext);
----

The
{javadoc-baseurl}/org/springframework/web/context/support/WebApplicationContextUtils.html[`WebApplicationContextUtils`]
class is for convenience, so you don't have to remember the name of the `ServletContext`
attribute. Its __getWebApplicationContext()__ method will return `null` if an object
doesn't exist under the `WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE`
key. Rather than risk getting `NullPointerExceptions` in your application, it's better
to use the `getRequiredWebApplicationContext()` method. This method throws an exception
when the `ApplicationContext` is missing.

Once you have a reference to the `WebApplicationContext`, you can retrieve beans by
their name or type. Most developers retrieve beans by name and then cast them to one of
their implemented interfaces.

Fortunately, most of the frameworks in this section have simpler ways of looking up
beans. Not only do they make it easy to get beans from a Spring container, but they also
allow you to use dependency injection on their controllers. Each web framework section
has more detail on its specific integration strategies.




[[jsf]]
=== JavaServer Faces 1.2
JavaServer Faces (JSF) is the JCP's standard component-based, event-driven web user
interface framework. As of Java EE 5, it is an official part of the Java EE umbrella.

For a popular JSF runtime as well as for popular JSF component libraries, check out the
http://myfaces.apache.org/[Apache MyFaces project]. The MyFaces project also provides
common JSF extensions such as http://myfaces.apache.org/orchestra/[MyFaces Orchestra]:
a Spring-based JSF extension that provides rich conversation scope support.

[NOTE]
====
Spring Web Flow 2.0 provides rich JSF support through its newly established Spring Faces
module, both for JSF-centric usage (as described in this section) and for Spring-centric
usage (using JSF views within a Spring MVC dispatcher). Check out the
http://projects.spring.io/spring-webflow[Spring Web Flow website] for details!
====

The key element in Spring's JSF integration is the JSF `ELResolver` mechanism.

[[jsf-springbeanfaceselresolver]]
==== SpringBeanFacesELResolver (JSF 1.2+)
`SpringBeanFacesELResolver` is a JSF 1.2 compliant `ELResolver` implementation,
integrating with the standard Unified EL as used by JSF 1.2 and JSP 2.1. Like
`SpringBeanVariableResolver`, it delegates to the Spring's 'business context'
`WebApplicationContext` __first__, then to the default resolver of the underlying JSF
implementation.

Configuration-wise, simply define `SpringBeanFacesELResolver` in your JSF 1.2
__faces-context.xml__ file:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<faces-config>
		<application>
			<el-resolver>org.springframework.web.jsf.el.SpringBeanFacesELResolver</el-resolver>
			...
		</application>
	</faces-config>
----


[[jsf-facescontextutils]]
==== FacesContextUtils
A custom `VariableResolver` works well when mapping one's properties to beans
in __faces-config.xml__, but at times one may need to grab a bean explicitly. The
{javadoc-baseurl}/org/springframework/web/jsf/FacesContextUtils.html[`FacesContextUtils`]
class makes this easy. It is similar to `WebApplicationContextUtils`, except that it
takes a `FacesContext` parameter rather than a `ServletContext` parameter.

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	ApplicationContext ctx = FacesContextUtils.getWebApplicationContext(FacesContext.getCurrentInstance());
----



[[struts]]
=== Apache Struts 2.x
Invented by Craig McClanahan, http://struts.apache.org[Struts] is an open source project
hosted by the Apache Software Foundation. At the time, it greatly simplified the
JSP/Servlet programming paradigm and won over many developers who were using proprietary
frameworks. It simplified the programming model, it was open source (and thus free as in
beer), and it had a large community, which allowed the project to grow and become popular
among Java web developers.

Check out the Struts
https://struts.apache.org/release/2.3.x/docs/spring-plugin.html[Spring Plugin] for the
built-in Spring integration shipped with Struts.



[[tapestry]]
=== Tapestry 5.x
From the http://tapestry.apache.org/[Tapestry homepage]:

Tapestry is a "__Component oriented framework for creating dynamic, robust,
highly scalable web applications in Java.__"

While Spring has its own <<mvc,powerful web layer>>, there are a number of unique
advantages to building an enterprise Java application using a combination of Tapestry
for the web user interface and the Spring container for the lower layers.

For more information, check out Tapestry's dedicated
https://tapestry.apache.org/integrating-with-spring-framework.html[integration module for
Spring].



[[web-integration-resources]]
=== Further Resources
Find below links to further resources about the various web frameworks described in this
chapter.

* The http://www.oracle.com/technetwork/java/javaee/javaserverfaces-139869.html[JSF] homepage
* The http://struts.apache.org/[Struts] homepage
* The http://tapestry.apache.org/[Tapestry] homepage



[[portlet]]
== Portlet MVC Framework


[[portlet-introduction]]
=== Introduction

.JSR-168 The Java Portlet Specification
****
For more general information about portlet development, please review a whitepaper from
Oracle entitled
http://www.oracle.com/technetwork/java/index-raji-test-141933.html["Introduction
to JSR 168"], and of course the
http://jcp.org/aboutJava/communityprocess/final/jsr168/[JSR-168 Specification] itself.
****

In addition to supporting conventional (servlet-based) Web development, Spring also
supports JSR-168 Portlet development. As much as possible, the Portlet MVC framework is
a mirror image of the Web MVC framework, and also uses the same underlying view
abstractions and integration technology. So, be sure to review the chapters entitled
<<mvc>> and <<view>> before continuing with this chapter.

[NOTE]
====
Bear in mind that while the concepts of Spring MVC are the same in Spring Portlet MVC,
there are some notable differences created by the unique workflow of JSR-168 portlets.
====

The main way in which portlet workflow differs from servlet workflow is that the request
to the portlet can have two distinct phases: the action phase and the render phase. The
action phase is executed only once and is where any 'backend' changes or actions occur,
such as making changes in a database. The render phase then produces what is displayed
to the user each time the display is refreshed. The critical point here is that for a
single overall request, the action phase is executed only once, but the render phase may
be executed multiple times. This provides (and requires) a clean separation between the
activities that modify the persistent state of your system and the activities that
generate what is displayed to the user.

.Spring Web Flow
****
Spring Web Flow (SWF) aims to be the best solution for the management of web application
page flow.

SWF integrates with existing frameworks like Spring MVC and JSF, in both Servlet and
Portlet environments. If you have a business process (or processes) that would benefit
from a conversational model as opposed to a purely request model, then SWF may be the
solution.

SWF allows you to capture logical page flows as self-contained modules that are reusable
in different situations, and as such is ideal for building web application modules that
guide the user through controlled navigations that drive business processes.

For more information about SWF, consult the Spring Web Flow website.
****

The dual phases of portlet requests are one of the real strengths of the JSR-168
specification. For example, dynamic search results can be updated routinely on the
display without the user explicitly rerunning the search. Most other portlet MVC
frameworks attempt to completely hide the two phases from the developer and make it look
as much like traditional servlet development as possible - we think this approach
removes one of the main benefits of using portlets. So, the separation of the two phases
is preserved throughout the Spring Portlet MVC framework. The primary manifestation of
this approach is that where the servlet version of the MVC classes will have one method
that deals with the request, the portlet version of the MVC classes will have two
methods that deal with the request: one for the action phase and one for the render
phase. For example, where the servlet version of `AbstractController` has the
`handleRequestInternal(..)` method, the portlet version of `AbstractController` has
`handleActionRequestInternal(..)` and `handleRenderRequestInternal(..)` methods.

The framework is designed around a `DispatcherPortlet` that dispatches requests to
handlers, with configurable handler mappings and view resolution, just as the
`DispatcherServlet` in the web framework does. File upload is also supported in the same
way.

Locale resolution and theme resolution are not supported in Portlet MVC - these areas
are in the purview of the portal/portlet container and are not appropriate at the Spring
level. However, all mechanisms in Spring that depend on the locale (such as
internationalization of messages) will still function properly because
`DispatcherPortlet` exposes the current locale in the same way as `DispatcherServlet`.



[[portlet-introduction-controller]]
==== Controllers - The C in MVC
The default handler is still a very simple `Controller` interface, offering just two
methods:

* `void handleActionRequest(request,response)`
* `ModelAndView handleRenderRequest(request,response)`

The framework also includes most of the same controller implementation hierarchy, such
as `AbstractController`, `SimpleFormController`, and so on. Data binding, command object
usage, model handling, and view resolution are all the same as in the servlet framework.



[[portlet-introduction-view]]
==== Views - The V in MVC
All the view rendering capabilities of the servlet framework are used directly via a
special bridge servlet named `ViewRendererServlet`. By using this servlet, the portlet
request is converted into a servlet request and the view can be rendered using the
entire normal servlet infrastructure. This means all the existing renderers, such as
JSP, Velocity, etc., can still be used within the portlet.



[[portlet-introduction-scope]]
==== Web-scoped beans
Spring Portlet MVC supports beans whose lifecycle is scoped to the current HTTP request
or HTTP `Session` (both normal and global). This is not a specific feature of Spring
Portlet MVC itself, but rather of the `WebApplicationContext` container(s) that Spring
Portlet MVC uses. These bean scopes are described in detail in
<<beans-factory-scopes-other>>




[[portlet-dispatcher]]
=== The DispatcherPortlet

Portlet MVC is a request-driven web MVC framework, designed around a portlet that
dispatches requests to controllers and offers other functionality facilitating the
development of portlet applications. Spring's `DispatcherPortlet` however, does more
than just that. It is completely integrated with the Spring `ApplicationContext` and
allows you to use every other feature Spring has.

Like ordinary portlets, the `DispatcherPortlet` is declared in the `portlet.xml` file of
your web application:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<portlet>
		<portlet-name>sample</portlet-name>
		<portlet-class>org.springframework.web.portlet.DispatcherPortlet</portlet-class>
		<supports>
			<mime-type>text/html</mime-type>
			<portlet-mode>view</portlet-mode>
		</supports>
		<portlet-info>
			<title>Sample Portlet</title>
		</portlet-info>
	</portlet>
----

The `DispatcherPortlet` now needs to be configured.

In the Portlet MVC framework, each `DispatcherPortlet` has its own
`WebApplicationContext`, which inherits all the beans already defined in the Root
`WebApplicationContext`. These inherited beans can be overridden in the portlet-specific
scope, and new scope-specific beans can be defined local to a given portlet instance.

The framework will, on initialization of a `DispatcherPortlet`, look for a file named
`[portlet-name]-portlet.xml` in the `WEB-INF` directory of your web application and
create the beans defined there (overriding the definitions of any beans defined with the
same name in the global scope).

The config location used by the `DispatcherPortlet` can be modified through a portlet
initialization parameter (see below for details).

The Spring `DispatcherPortlet` has a few special beans it uses, in order to be able to
process requests and render the appropriate views. These beans are included in the
Spring framework and can be configured in the `WebApplicationContext`, just as any other
bean would be configured. Each of those beans is described in more detail below. Right
now, we'll just mention them, just to let you know they exist and to enable us to go on
talking about the `DispatcherPortlet`. For most of the beans, defaults are provided so
you don't have to worry about configuring them.

[[portlet-webappctx-special-beans-tbl]]
.Special beans in the WebApplicationContext
[cols="1,4"]
|===
| Expression| Explanation

| handler mapping(s)
| (<<portlet-handlermapping>>) a list of pre- and post-processors and controllers that
  will be executed if they match certain criteria (for instance a matching portlet mode
  specified with the controller)

| controller(s)
| (<<portlet-controller>>) the beans providing the actual functionality (or at least,
  access to the functionality) as part of the MVC triad

| view resolver
| (<<portlet-viewresolver>>) capable of resolving view names to view definitions

| multipart resolver
| (<<portlet-multipart>>) offers functionality to process file uploads from HTML forms

| handler exception resolver
| (<<portlet-exceptionresolver>>) offers functionality to map exceptions to views or
  implement other more complex exception handling code
|===

When a `DispatcherPortlet` is setup for use and a request comes in for that specific
`DispatcherPortlet`, it starts processing the request. The list below describes the
complete process a request goes through if handled by a `DispatcherPortlet`:

. The locale returned by `PortletRequest.getLocale()` is bound to the request to let
elements in the process resolve the locale to use when processing the request (rendering
the view, preparing data, etc.).
. If a multipart resolver is specified and this is an `ActionRequest`, the request is
inspected for multiparts and if they are found, it is wrapped in a
`MultipartActionRequest` for further processing by other elements in the process. (See
<<portlet-multipart>> for further information about multipart handling).
. An appropriate handler is searched for. If a handler is found, the execution chain
associated with the handler (pre-processors, post-processors, controllers) will be
executed in order to prepare a model.
. If a model is returned, the view is rendered, using the view resolver that has been
configured with the `WebApplicationContext`. If no model is returned (which could be due
to a pre- or post-processor intercepting the request, for example, for security
reasons), no view is rendered, since the request could already have been fulfilled.

Exceptions that are thrown during processing of the request get picked up by any of the
handler exception resolvers that are declared in the `WebApplicationContext`. Using
these exception resolvers you can define custom behavior in case such exceptions get
thrown.

You can customize Spring's `DispatcherPortlet` by adding context parameters in the
`portlet.xml` file or portlet init-parameters. The possibilities are listed below.

[[portlet-dpp-init-params]]
.DispatcherPortlet initialization parameters
[cols="1,4"]
|===
| Parameter| Explanation

| `contextClass`
| Class that implements `WebApplicationContext`, which will be used to instantiate the
  context used by this portlet. If this parameter isn't specified, the
  `XmlPortletApplicationContext` will be used.

| `contextConfigLocation`
| String which is passed to the context instance (specified by `contextClass`) to
  indicate where context(s) can be found. The String is potentially split up into
  multiple Strings (using a comma as a delimiter) to support multiple contexts (in case
  of multiple context locations, for beans that are defined twice, the latest takes
  precedence).

| `namespace`
| The namespace of the `WebApplicationContext`. Defaults to `[portlet-name]-portlet`.

| `viewRendererUrl`
| The URL at which `DispatcherPortlet` can access an instance of `ViewRendererServlet`
  (see <<portlet-viewservlet>>).
|===




[[portlet-viewservlet]]
=== The ViewRendererServlet

The rendering process in Portlet MVC is a bit more complex than in Web MVC. In order to
reuse all the <<view,view technologies>> from Spring Web MVC, we must convert the
`PortletRequest` / `PortletResponse` to `HttpServletRequest` / `HttpServletResponse` and
then call the `render` method of the `View`. To do this, `DispatcherPortlet` uses a
special servlet that exists for just this purpose: the `ViewRendererServlet`.

In order for `DispatcherPortlet` rendering to work, you must declare an instance of the
`ViewRendererServlet` in the `web.xml` file for your web application as follows:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<servlet>
		<servlet-name>ViewRendererServlet</servlet-name>
		<servlet-class>org.springframework.web.servlet.ViewRendererServlet</servlet-class>
	</servlet>

	<servlet-mapping>
		<servlet-name>ViewRendererServlet</servlet-name>
		<url-pattern>/WEB-INF/servlet/view</url-pattern>
	</servlet-mapping>
----

To perform the actual rendering, `DispatcherPortlet` does the following:

. Binds the `WebApplicationContext` to the request as an attribute under the same
`WEB_APPLICATION_CONTEXT_ATTRIBUTE` key that `DispatcherServlet` uses.
. Binds the `Model` and `View` objects to the request to make them available to the
`ViewRendererServlet`.
. Constructs a `PortletRequestDispatcher` and performs an `include` using the `/WEB-
INF/servlet/view` URL that is mapped to the `ViewRendererServlet`.

The `ViewRendererServlet` is then able to call the `render` method on the `View` with
the appropriate arguments.

The actual URL for the `ViewRendererServlet` can be changed using `DispatcherPortlet`'s
`viewRendererUrl` configuration parameter.




[[portlet-controller]]
=== Controllers
The controllers in Portlet MVC are very similar to the Web MVC Controllers, and porting
code from one to the other should be simple.

The basis for the Portlet MVC controller architecture is the
`org.springframework.web.portlet.mvc.Controller` interface, which is listed below.

[source,java,indent=0]
----
	public interface Controller {

		/**
		 * Process the render request and return a ModelAndView object which the
		 * DispatcherPortlet will render.
		 */
		ModelAndView handleRenderRequest(RenderRequest request,
				RenderResponse response) throws Exception;

		/**
		 * Process the action request. There is nothing to return.
		 */
		void handleActionRequest(ActionRequest request,
				ActionResponse response) throws Exception;

	}
----

As you can see, the Portlet `Controller` interface requires two methods that handle the
two phases of a portlet request: the action request and the render request. The action
phase should be capable of handling an action request, and the render phase should be
capable of handling a render request and returning an appropriate model and view. While
the `Controller` interface is quite abstract, Spring Portlet MVC offers several
controllers that already contain a lot of the functionality you might need; most of
these are very similar to controllers from Spring Web MVC. The `Controller` interface
just defines the most common functionality required of every controller: handling an
action request, handling a render request, and returning a model and a view.



[[portlet-controller-abstractcontroller]]
==== AbstractController and PortletContentGenerator

Of course, just a `Controller` interface isn't enough. To provide a basic
infrastructure, all of Spring Portlet MVC's ++Controller++s inherit from
`AbstractController`, a class offering access to Spring's `ApplicationContext` and
control over caching.

[[portlet-ac-features]]
.Features offered by the AbstractController
[cols="1,4"]
|===
| Parameter| Explanation

| `requireSession`
| Indicates whether or not this `Controller` requires a session to do its work. This
  feature is offered to all controllers. If a session is not present when such a
  controller receives a request, the user is informed using a `SessionRequiredException`.

| `synchronizeSession`
| Use this if you want handling by this controller to be synchronized on the user's
  session. To be more specific, the extending controller will override the
  `handleRenderRequestInternal(..)` and `handleActionRequestInternal(..)` methods, which
  will be synchronized on the user's session if you specify this variable.

| `renderWhenMinimized`
| If you want your controller to actually render the view when the portlet is in a
  minimized state, set this to true. By default, this is set to false so that portlets
  that are in a minimized state don't display any content.

| `cacheSeconds`
| When you want a controller to override the default cache expiration defined for the
  portlet, specify a positive integer here. By default it is set to `-1`, which does not
  change the default caching. Setting it to `0` will ensure the result is never cached.
|===

The `requireSession` and `cacheSeconds` properties are declared on the
`PortletContentGenerator` class, which is the superclass of `AbstractController`) but
are included here for completeness.

When using the `AbstractController` as a base class for your controllers (which is not
recommended since there are a lot of other controllers that might already do the job for
you) you only have to override either the `handleActionRequestInternal(ActionRequest,
ActionResponse)` method or the `handleRenderRequestInternal(RenderRequest,
RenderResponse)` method (or both), implement your logic, and return a `ModelAndView`
object (in the case of `handleRenderRequestInternal`).

The default implementations of both `handleActionRequestInternal(..)` and
`handleRenderRequestInternal(..)` throw a `PortletException`. This is consistent with
the behavior of `GenericPortlet` from the JSR- 168 Specification API. So you only need
to override the method that your controller is intended to handle.

Here is short example consisting of a class and a declaration in the web application
context.

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	package samples;

	import javax.portlet.RenderRequest;
	import javax.portlet.RenderResponse;

	import org.springframework.web.portlet.mvc.AbstractController;
	import org.springframework.web.portlet.ModelAndView;

	public class SampleController extends AbstractController {

		public ModelAndView handleRenderRequestInternal(RenderRequest request, RenderResponse response) {
			ModelAndView mav = new ModelAndView("foo");
			mav.addObject("message", "Hello World!");
			return mav;
		}

	}
----

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="sampleController" class="samples.SampleController">
		<property name="cacheSeconds" value="120"/>
	</bean>
----

The class above and the declaration in the web application context is all you need
besides setting up a handler mapping (see <<portlet-handlermapping>>) to get this very
simple controller working.



[[portlet-controller-simple]]
==== Other simple controllers
Although you can extend `AbstractController`, Spring Portlet MVC provides a number of
concrete implementations which offer functionality that is commonly used in simple MVC
applications.

The `ParameterizableViewController` is basically the same as the example above, except
for the fact that you can specify the view name that it will return in the web
application context (no need to hard-code the view name).

The `PortletModeNameViewController` uses the current mode of the portlet as the view
name. So, if your portlet is in View mode (i.e. `PortletMode.VIEW`) then it uses "view"
as the view name.



[[portlet-controller-command]]
==== Command Controllers
Spring Portlet MVC has the exact same hierarchy of __command controllers__ as Spring Web
MVC. They provide a way to interact with data objects and dynamically bind parameters
from the `PortletRequest` to the data object specified. Your data objects don't have to
implement a framework-specific interface, so you can directly manipulate your persistent
objects if you desire. Let's examine what command controllers are available, to get an
overview of what you can do with them:

* `AbstractCommandController` - a command controller you can use to create your own
  command controller, capable of binding request parameters to a data object you
  specify. This class does not offer form functionality, it does however offer
  validation features and lets you specify in the controller itself what to do with the
  command object that has been filled with the parameters from the request.
* `AbstractFormController` - an abstract controller offering form submission support.
  Using this controller you can model forms and populate them using a command object you
  retrieve in the controller. After a user has filled the form, `AbstractFormController`
  binds the fields, validates, and hands the object back to the controller to take
  appropriate action. Supported features are: invalid form submission (resubmission),
  validation, and normal form workflow. You implement methods to determine which views
  are used for form presentation and success. Use this controller if you need forms, but
  don't want to specify what views you're going to show the user in the application
  context.
* `SimpleFormController` - a concrete `AbstractFormController` that provides even more
  support when creating a form with a corresponding command object. The
  `SimpleFormController` lets you specify a command object, a viewname for the form, a
  viewname for the page you want to show the user when form submission has succeeded,
  and more.
* `AbstractWizardFormController` -- a concrete `AbstractFormController` that provides a
  wizard-style interface for editing the contents of a command object across multiple
  display pages. Supports multiple user actions: finish, cancel, or page change, all of
  which are easily specified in request parameters from the view.

These command controllers are quite powerful, but they do require a detailed
understanding of how they operate in order to use them efficiently. Carefully review the
javadocs for this entire hierarchy and then look at some sample implementations before
you start using them.



[[portlet-controller-wrapping]]
==== PortletWrappingController

Instead of developing new controllers, it is possible to use existing portlets and map
requests to them from a `DispatcherPortlet`. Using the `PortletWrappingController`, you
can instantiate an existing `Portlet` as a `Controller` as follows:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="myPortlet" class="org.springframework.web.portlet.mvc.PortletWrappingController">
		<property name="portletClass" value="sample.MyPortlet"/>
		<property name="portletName" value="my-portlet"/>
		<property name="initParameters">
			<value>config=/WEB-INF/my-portlet-config.xml</value>
		</property>
	</bean>
----

This can be very valuable since you can then use interceptors to pre-process and
post-process requests going to these portlets. Since JSR-168 does not support any kind
of filter mechanism, this is quite handy. For example, this can be used to wrap the
Hibernate `OpenSessionInViewInterceptor` around a MyFaces JSF Portlet.




[[portlet-handlermapping]]
=== Handler mappings
Using a handler mapping you can map incoming portlet requests to appropriate handlers.
There are some handler mappings you can use out of the box, for example, the
`PortletModeHandlerMapping`, but let's first examine the general concept of a
`HandlerMapping`.

Note: We are intentionally using the term "Handler" here instead of "Controller".
`DispatcherPortlet` is designed to be used with other ways to process requests than just
Spring Portlet MVC's own Controllers. A Handler is any Object that can handle portlet
requests. Controllers are an example of Handlers, and they are of course the default. To
use some other framework with `DispatcherPortlet`, a corresponding implementation of
`HandlerAdapter` is all that is needed.

The functionality a basic `HandlerMapping` provides is the delivering of a
`HandlerExecutionChain`, which must contain the handler that matches the incoming
request, and may also contain a list of handler interceptors that are applied to the
request. When a request comes in, the `DispatcherPortlet` will hand it over to the
handler mapping to let it inspect the request and come up with an appropriate
`HandlerExecutionChain`. Then the `DispatcherPortlet` will execute the handler and
interceptors in the chain (if any). These concepts are all exactly the same as in Spring
Web MVC.

The concept of configurable handler mappings that can optionally contain interceptors
(executed before or after the actual handler was executed, or both) is extremely
powerful. A lot of supporting functionality can be built into a custom `HandlerMapping`.
Think of a custom handler mapping that chooses a handler not only based on the portlet
mode of the request coming in, but also on a specific state of the session associated
with the request.

In Spring Web MVC, handler mappings are commonly based on URLs. Since there is really no
such thing as a URL within a Portlet, we must use other mechanisms to control mappings.
The two most common are the portlet mode and a request parameter, but anything available
to the portlet request can be used in a custom handler mapping.

The rest of this section describes three of Spring Portlet MVC's most commonly used
handler mappings. They all extend `AbstractHandlerMapping` and share the following
properties:

* `interceptors`: The list of interceptors to use. ++HandlerInterceptor++s are discussed
  in <<portlet-handlermapping-interceptor>>.
* `defaultHandler`: The default handler to use, when this handler mapping does not
  result in a matching handler.
* `order`: Based on the value of the order property (see the
  `org.springframework.core.Ordered` interface), Spring will sort all handler mappings
  available in the context and apply the first matching handler.
* `lazyInitHandlers`: Allows for lazy initialization of singleton handlers (prototype
  handlers are always lazily initialized). Default value is false. This property is
  directly implemented in the three concrete Handlers.



[[portlet-handlermapping-portletmode]]
==== PortletModeHandlerMapping

This is a simple handler mapping that maps incoming requests based on the current mode
of the portlet (e.g. 'view', 'edit', 'help'). An example:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean class="org.springframework.web.portlet.handler.PortletModeHandlerMapping">
		<property name="portletModeMap">
			<map>
				<entry key="view" value-ref="viewHandler"/>
				<entry key="edit" value-ref="editHandler"/>
				<entry key="help" value-ref="helpHandler"/>
			</map>
		</property>
	</bean>
----



[[portlet-handlermapping-parameter]]
==== ParameterHandlerMapping

If we need to navigate around to multiple controllers without changing portlet mode, the
simplest way to do this is with a request parameter that is used as the key to control
the mapping.

`ParameterHandlerMapping` uses the value of a specific request parameter to control the
mapping. The default name of the parameter is `'action'`, but can be changed using the
`'parameterName'` property.

The bean configuration for this mapping will look something like this:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean class="org.springframework.web.portlet.handler.ParameterHandlerMapping">
		<property name="parameterMap">
			<map>
				<entry key="add" value-ref="addItemHandler"/>
				<entry key="edit" value-ref="editItemHandler"/>
				<entry key="delete" value-ref="deleteItemHandler"/>
			</map>
		</property>
	</bean>
----



[[portlet-handlermapping-portletmodeparameter]]
==== PortletModeParameterHandlerMapping

The most powerful built-in handler mapping, `PortletModeParameterHandlerMapping`
combines the capabilities of the two previous ones to allow different navigation within
each portlet mode.

Again the default name of the parameter is "action", but can be changed using the
`parameterName` property.

By default, the same parameter value may not be used in two different portlet modes.
This is so that if the portal itself changes the portlet mode, the request will no
longer be valid in the mapping. This behavior can be changed by setting the
`allowDupParameters` property to true. However, this is not recommended.

The bean configuration for this mapping will look something like this:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean class="org.springframework.web.portlet.handler.PortletModeParameterHandlerMapping">
		<property name="portletModeParameterMap">
			<map>
				<entry key="view"> <!-- 'view' portlet mode -->
					<map>
						<entry key="add" value-ref="addItemHandler"/>
						<entry key="edit" value-ref="editItemHandler"/>
						<entry key="delete" value-ref="deleteItemHandler"/>
					</map>
				</entry>
				<entry key="edit"> <!-- 'edit' portlet mode -->
					<map>
						<entry key="prefs" value-ref="prefsHandler"/>
						<entry key="resetPrefs" value-ref="resetPrefsHandler"/>
					</map>
				</entry>
			</map>
		</property>
	</bean>
----

This mapping can be chained ahead of a `PortletModeHandlerMapping`, which can then
provide defaults for each mode and an overall default as well.



[[portlet-handlermapping-interceptor]]
==== Adding HandlerInterceptors

Spring's handler mapping mechanism has a notion of handler interceptors, which can be
extremely useful when you want to apply specific functionality to certain requests, for
example, checking for a principal. Again Spring Portlet MVC implements these concepts in
the same way as Web MVC.

Interceptors located in the handler mapping must implement `HandlerInterceptor` from the
`org.springframework.web.portlet` package. Just like the servlet version, this interface
defines three methods: one that will be called before the actual handler will be
executed ( `preHandle`), one that will be called after the handler is executed (
`postHandle`), and one that is called after the complete request has finished (
`afterCompletion`). These three methods should provide enough flexibility to do all
kinds of pre- and post- processing.

The `preHandle` method returns a boolean value. You can use this method to break or
continue the processing of the execution chain. When this method returns `true`, the
handler execution chain will continue. When it returns `false`, the `DispatcherPortlet`
assumes the interceptor itself has taken care of requests (and, for example, rendered an
appropriate view) and does not continue executing the other interceptors and the actual
handler in the execution chain.

The `postHandle` method is only called on a `RenderRequest`. The `preHandle` and
`afterCompletion` methods are called on both an `ActionRequest` and a `RenderRequest`.
If you need to execute logic in these methods for just one type of request, be sure to
check what kind of request it is before processing it.



[[portlet-handlermapping-interceptoradapter]]
==== HandlerInterceptorAdapter

As with the servlet package, the portlet package has a concrete implementation of
`HandlerInterceptor` called `HandlerInterceptorAdapter`. This class has empty versions
of all the methods so that you can inherit from this class and implement just one or two
methods when that is all you need.



[[portlet-handlermapping-parameterinterceptor]]
==== ParameterMappingInterceptor

The portlet package also has a concrete interceptor named `ParameterMappingInterceptor`
that is meant to be used directly with `ParameterHandlerMapping` and
`PortletModeParameterHandlerMapping`. This interceptor will cause the parameter that is
being used to control the mapping to be forwarded from an `ActionRequest` to the
subsequent `RenderRequest`. This will help ensure that the `RenderRequest` is mapped to
the same Handler as the `ActionRequest`. This is done in the `preHandle` method of the
interceptor, so you can still modify the parameter value in your handler to change where
the `RenderRequest` will be mapped.

Be aware that this interceptor is calling `setRenderParameter` on the `ActionResponse`,
which means that you cannot call `sendRedirect` in your handler when using this
interceptor. If you need to do external redirects then you will either need to forward
the mapping parameter manually or write a different interceptor to handle this for you.




[[portlet-viewresolver]]
=== Views and resolving them
As mentioned previously, Spring Portlet MVC directly reuses all the view technologies
from Spring Web MVC. This includes not only the various `View` implementations
themselves, but also the `ViewResolver` implementations. For more information, refer to
<<view>> and <<mvc-viewresolver>> respectively.

A few items on using the existing `View` and `ViewResolver` implementations are worth
mentioning:

* Most portals expect the result of rendering a portlet to be an HTML fragment. So,
  things like JSP/JSTL, Velocity, FreeMarker, and XSLT all make sense. But it is
  unlikely that views that return other document types will make any sense in a portlet
  context.
* There is no such thing as an HTTP redirect from within a portlet (the
  `sendRedirect(..)` method of `ActionResponse` cannot be used to stay within the
  portal). So, `RedirectView` and use of the `'redirect:'` prefix will __not__ work
  correctly from within Portlet MVC.
* It may be possible to use the `'forward:'` prefix from within Portlet MVC. However,
  remember that since you are in a portlet, you have no idea what the current URL looks
  like. This means you cannot use a relative URL to access other resources in your web
  application and that you will have to use an absolute URL.

Also, for JSP development, the new Spring Taglib and the new Spring Form Taglib both
work in portlet views in exactly the same way that they work in servlet views.




[[portlet-multipart]]
=== Multipart (file upload) support
Spring Portlet MVC has built-in multipart support to handle file uploads in portlet
applications, just like Web MVC does. The design for the multipart support is done with
pluggable `PortletMultipartResolver` objects, defined in the
`org.springframework.web.portlet.multipart` package. Spring provides a
`PortletMultipartResolver` for use with
http://jakarta.apache.org/commons/fileupload[Commons FileUpload]. How uploading files is
supported will be described in the rest of this section.

By default, no multipart handling will be done by Spring Portlet MVC, as some developers
will want to handle multiparts themselves. You will have to enable it yourself by adding
a multipart resolver to the web application's context. After you have done that,
`DispatcherPortlet` will inspect each request to see if it contains a multipart. If no
multipart is found, the request will continue as expected. However, if a multipart is
found in the request, the `PortletMultipartResolver` that has been declared in your
context will be used. After that, the multipart attribute in your request will be
treated like any other attribute.

[NOTE]
====
Any configured `PortletMultipartResolver` bean __must__ have the following id (or name):
" `portletMultipartResolver`". If you have defined your `PortletMultipartResolver` with
any other name, then the `DispatcherPortlet` will __not__ find your
`PortletMultipartResolver`, and consequently no multipart support will be in effect.
====



[[portlet-multipart-resolver]]
==== Using the PortletMultipartResolver

The following example shows how to use the `CommonsPortletMultipartResolver`:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="portletMultipartResolver"
			class="org.springframework.web.portlet.multipart.CommonsPortletMultipartResolver">
		<!-- one of the properties available; the maximum file size in bytes -->
		<property name="maxUploadSize" value="100000"/>
	</bean>
----

Of course you also need to put the appropriate jars in your classpath for the multipart
resolver to work. In the case of the `CommonsMultipartResolver`, you need to use
`commons-fileupload.jar`. Be sure to use at least version 1.1 of Commons FileUpload as
previous versions do not support JSR-168 Portlet applications.

Now that you have seen how to set Portlet MVC up to handle multipart requests, let's
talk about how to actually use it. When `DispatcherPortlet` detects a multipart request,
it activates the resolver that has been declared in your context and hands over the
request. What the resolver then does is wrap the current `ActionRequest` in a
`MultipartActionRequest` that has support for multipart file uploads. Using the
`MultipartActionRequest` you can get information about the multiparts contained by this
request and actually get access to the multipart files themselves in your controllers.

Note that you can only receive multipart file uploads as part of an `ActionRequest`, not
as part of a `RenderRequest`.



[[portlet-multipart-forms]]
==== Handling a file upload in a form
After the `PortletMultipartResolver` has finished doing its job, the request will be
processed like any other. To use the `PortletMultipartResolver`, create a form with an
upload field (see example below), then let Spring bind the file onto your form (backing
object). To actually let the user upload a file, we have to create a (JSP/HTML) form:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<h1>Please upload a file</h1>
	<form method="post" action="<portlet:actionURL/>" enctype="multipart/form-data">
		<input type="file" name="file"/>
		<input type="submit"/>
	</form>
----

As you can see, we've created a field named "file" that matches the property of the bean
that holds the `byte[]` array. Furthermore we've added the encoding attribute (
`enctype="multipart/form-data"`), which is necessary to let the browser know how to
encode the multipart fields (do not forget this!).

Just as with any other property that's not automagically convertible to a string or
primitive type, to be able to put binary data in your objects you have to register a
custom editor with the `PortletRequestDataBinder`. There are a couple of editors
available for handling files and setting the results on an object. There's a
`StringMultipartFileEditor` capable of converting files to Strings (using a user-defined
character set), and there is a `ByteArrayMultipartFileEditor` which converts files to
byte arrays. They function analogous to the `CustomDateEditor`.

So, to be able to upload files using a form, declare the resolver, a mapping to a
controller that will process the bean, and the controller itself.

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<bean id="portletMultipartResolver"
			class="org.springframework.web.portlet.multipart.CommonsPortletMultipartResolver"/>

	<bean class="org.springframework.web.portlet.handler.PortletModeHandlerMapping">
		<property name="portletModeMap">
			<map>
				<entry key="view" value-ref="fileUploadController"/>
			</map>
		</property>
	</bean>

	<bean id="fileUploadController" class="examples.FileUploadController">
		<property name="commandClass" value="examples.FileUploadBean"/>
		<property name="formView" value="fileuploadform"/>
		<property name="successView" value="confirmation"/>
	</bean>
----

After that, create the controller and the actual class to hold the file property.

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class FileUploadController extends SimpleFormController {

		public void onSubmitAction(ActionRequest request, ActionResponse response,
				Object command, BindException errors) throws Exception {

			// cast the bean
			FileUploadBean bean = (FileUploadBean) command;

			// let's see if there's content there
			byte[] file = bean.getFile();
			if (file == null) {
				// hmm, that's strange, the user did not upload anything
			}

			// do something with the file here
		}

		protected void initBinder(PortletRequest request,
				PortletRequestDataBinder binder) throws Exception {
			// to actually be able to convert Multipart instance to byte[]
			// we have to register a custom editor
			binder.registerCustomEditor(byte[].class, new ByteArrayMultipartFileEditor());
			// now Spring knows how to handle multipart object and convert
		}

	}

	public class FileUploadBean {

		private byte[] file;

		public void setFile(byte[] file) {
			this.file = file;
		}

		public byte[] getFile() {
			return file;
		}

	}
----

As you can see, the `FileUploadBean` has a property of type `byte[]` that holds the
file. The controller registers a custom editor to let Spring know how to actually
convert the multipart objects the resolver has found to properties specified by the
bean. In this example, nothing is done with the `byte[]` property of the bean itself,
but in practice you can do whatever you want (save it in a database, mail it to
somebody, etc).

An equivalent example in which a file is bound straight to a String-typed property on a
form backing object might look like this:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class FileUploadController extends SimpleFormController {

		public void onSubmitAction(ActionRequest request, ActionResponse response,
				Object command, BindException errors) throws Exception {

			// cast the bean
			FileUploadBean bean = (FileUploadBean) command;

			// let's see if there's content there
			String file = bean.getFile();
			if (file == null) {
				// hmm, that's strange, the user did not upload anything
			}

			// do something with the file here
		}

		protected void initBinder(PortletRequest request,
				PortletRequestDataBinder binder) throws Exception {

			// to actually be able to convert Multipart instance to a String
			// we have to register a custom editor
			binder.registerCustomEditor(String.class, new StringMultipartFileEditor());
			// now Spring knows how to handle multipart objects and convert
		}
	}

	public class FileUploadBean {

		private String file;

		public void setFile(String file) {
			this.file = file;
		}

		public String getFile() {
			return file;
		}
	}
----

Of course, this last example only makes (logical) sense in the context of uploading a
plain text file (it wouldn't work so well in the case of uploading an image file).

The third (and final) option is where one binds directly to a `MultipartFile` property
declared on the (form backing) object's class. In this case one does not need to
register any custom property editor because there is no type conversion to be performed.

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class FileUploadController extends SimpleFormController {

		public void onSubmitAction(ActionRequest request, ActionResponse response,
				Object command, BindException errors) throws Exception {

			// cast the bean
			FileUploadBean bean = (FileUploadBean) command;

			// let's see if there's content there
			MultipartFile file = bean.getFile();
			if (file == null) {
				// hmm, that's strange, the user did not upload anything
			}

			// do something with the file here
		}
	}

	public class FileUploadBean {

		private MultipartFile file;

		public void setFile(MultipartFile file) {
			this.file = file;
		}

		public MultipartFile getFile() {
			return file;
		}

	}
----




[[portlet-exceptionresolver]]
=== Handling exceptions
Just like Servlet MVC, Portlet MVC provides ++HandlerExceptionResolver++s to ease the
pain of unexpected exceptions that occur while your request is being processed by a
handler that matched the request. Portlet MVC also provides a portlet-specific, concrete
`SimpleMappingExceptionResolver` that enables you to take the class name of any
exception that might be thrown and map it to a view name.




[[portlet-annotation]]
=== Annotation-based controller configuration
Spring 2.5 introduced an annotation-based programming model for MVC controllers, using
annotations such as `@RequestMapping`, `@RequestParam`, `@ModelAttribute`, etc. This
annotation support is available for both Servlet MVC and Portlet MVC. Controllers
implemented in this style do not have to extend specific base classes or implement
specific interfaces. Furthermore, they do not usually have direct dependencies on
Servlet or Portlet API's, although they can easily get access to Servlet or Portlet
facilities if desired.

The following sections document these annotations and how they are most commonly used in
a Portlet environment.



[[portlet-ann-setup]]
==== Setting up the dispatcher for annotation support
__`@RequestMapping` will only be processed if a corresponding `HandlerMapping` (for
type level annotations) and/or `HandlerAdapter` (for method level annotations) is
present in the dispatcher.__ This is the case by default in both `DispatcherServlet` and
`DispatcherPortlet`.

However, if you are defining custom `HandlerMappings` or `HandlerAdapters`, then you
need to make sure that a corresponding custom `DefaultAnnotationHandlerMapping` and/or
`AnnotationMethodHandlerAdapter` is defined as well - provided that you intend to use
`@RequestMapping`.

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			http://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean class="org.springframework.web.portlet.mvc.annotation.DefaultAnnotationHandlerMapping"/>

		<bean class="org.springframework.web.portlet.mvc.annotation.AnnotationMethodHandlerAdapter"/>

		// ... (controller bean definitions) ...

	</beans>
----

Defining a `DefaultAnnotationHandlerMapping` and/or `AnnotationMethodHandlerAdapter`
explicitly also makes sense if you would like to customize the mapping strategy, e.g.
specifying a custom `WebBindingInitializer` (see below).



[[portlet-ann-controller]]
==== Defining a controller with @Controller

The `@Controller` annotation indicates that a particular class serves the role of a
__controller__. There is no need to extend any controller base class or reference the
Portlet API. You are of course still able to reference Portlet-specific features if you
need to.

The basic purpose of the `@Controller` annotation is to act as a stereotype for the
annotated class, indicating its role. The dispatcher will scan such annotated classes
for mapped methods, detecting `@RequestMapping` annotations (see the next section).

Annotated controller beans may be defined explicitly, using a standard Spring bean
definition in the dispatcher's context. However, the `@Controller` stereotype also
allows for autodetection, aligned with Spring 2.5's general support for detecting
component classes in the classpath and auto-registering bean definitions for them.

To enable autodetection of such annotated controllers, you have to add component
scanning to your configuration. This is easily achieved by using the __spring-context__
schema as shown in the following XML snippet:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:p="http://www.springframework.org/schema/p"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			http://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			http://www.springframework.org/schema/context/spring-context.xsd">

		<context:component-scan base-package="org.springframework.samples.petportal.portlet"/>

		// ...

	</beans>
----



[[portlet-ann-requestmapping]]
==== Mapping requests with @RequestMapping

The `@RequestMapping` annotation is used to map portlet modes like 'VIEW'/'EDIT' onto an
entire class or a particular handler method. Typically the type-level annotation maps a
specific mode (or mode plus parameter condition) onto a form controller, with additional
method-level annotations 'narrowing' the primary mapping for specific portlet request
parameters.

[TIP]
====

`@RequestMapping` at the type level may be used for plain implementations of the
`Controller` interface as well. In this case, the request processing code would follow
the traditional `handle(Action|Render)Request` signature, while the controller's mapping
would be expressed through an `@RequestMapping` annotation. This works for pre-built
`Controller` base classes, such as `SimpleFormController`, too.

In the following discussion, we'll focus on controllers that are based on annotated
handler methods.
====

The following is an example of a form controller from the PetPortal sample application
using this annotation:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Controller
	@RequestMapping("EDIT")
	@SessionAttributes("site")
	public class PetSitesEditController {

		private Properties petSites;

		public void setPetSites(Properties petSites) {
			this.petSites = petSites;
		}

		@ModelAttribute("petSites")
		public Properties getPetSites() {
			return this.petSites;
		}

		@RequestMapping // default (action=list)
		public String showPetSites() {
			return "petSitesEdit";
		}

		@RequestMapping(params = "action=add") // render phase
		public String showSiteForm(Model model) {
			// Used for the initial form as well as for redisplaying with errors.
			if (!model.containsAttribute("site")) {
				model.addAttribute("site", new PetSite());
			}

			return "petSitesAdd";
		}

		@RequestMapping(params = "action=add") // action phase
		public void populateSite(@ModelAttribute("site") PetSite petSite,
				BindingResult result, SessionStatus status, ActionResponse response) {
			new PetSiteValidator().validate(petSite, result);
			if (!result.hasErrors()) {
				this.petSites.put(petSite.getName(), petSite.getUrl());
				status.setComplete();
				response.setRenderParameter("action", "list");
			}
		}

		@RequestMapping(params = "action=delete")
		public void removeSite(@RequestParam("site") String site, ActionResponse response) {
			this.petSites.remove(site);
			response.setRenderParameter("action", "list");
		}
	}
----



[[portlet-ann-requestmapping-arguments]]
==== Supported handler method arguments
Handler methods which are annotated with `@RequestMapping` are allowed to have very
flexible signatures. They may have arguments of the following types, in arbitrary order
(except for validation results, which need to follow right after the corresponding
command object, if desired):

* Request and/or response objects (Portlet API). You may choose any specific
  request/response type, e.g. PortletRequest / ActionRequest / RenderRequest. An
  explicitly declared action/render argument is also used for mapping specific request
  types onto a handler method (in case of no other information given that differentiates
  between action and render requests).
* Session object (Portlet API): of type PortletSession. An argument of this type will
  enforce the presence of a corresponding session. As a consequence, such an argument
  will never be `null`.
* `org.springframework.web.context.request.WebRequest` or
  `org.springframework.web.context.request.NativeWebRequest`. Allows for generic request
  parameter access as well as request/session attribute access, without ties to the
  native Servlet/Portlet API.
* `java.util.Locale` for the current request locale (the portal locale in a Portlet
  environment).
* `java.util.TimeZone` / `java.time.ZoneId` for the current request time zone.
* `java.io.InputStream` / `java.io.Reader` for access to the request's content. This
  will be the raw InputStream/Reader as exposed by the Portlet API.
* `java.io.OutputStream` / `java.io.Writer` for generating the response's content. This
  will be the raw OutputStream/Writer as exposed by the Portlet API.
* `@RequestParam` annotated parameters for access to specific Portlet request
  parameters. Parameter values will be converted to the declared method argument type.
* `java.util.Map` / `org.springframework.ui.Model` / `org.springframework.ui.ModelMap`
  for enriching the implicit model that will be exposed to the web view.
* Command/form objects to bind parameters to: as bean properties or fields, with
  customizable type conversion, depending on `@InitBinder` methods and/or the
  HandlerAdapter configuration - see the " `webBindingInitializer`" property on
  `AnnotationMethodHandlerAdapter`. Such command objects along with their validation
  results will be exposed as model attributes, by default using the non-qualified
  command class name in property notation (e.g. "orderAddress" for type
  "mypackage.OrderAddress"). Specify a parameter-level `ModelAttribute` annotation for
  declaring a specific model attribute name.
* `org.springframework.validation.Errors` /
  `org.springframework.validation.BindingResult` validation results for a preceding
  command/form object (the immediate preceding argument).
* `org.springframework.web.bind.support.SessionStatus` status handle for marking form
  processing as complete (triggering the cleanup of session attributes that have been
  indicated by the `@SessionAttributes` annotation at the handler type level).

The following return types are supported for handler methods:

* A `ModelAndView` object, with the model implicitly enriched with command objects and
  the results of `@ModelAttribute` annotated reference data accessor methods.
* A `Model` object, with the view name implicitly determined through a
  `RequestToViewNameTranslator` and the model implicitly enriched with command objects
  and the results of `@ModelAttribute` annotated reference data accessor methods.
* A `Map` object for exposing a model, with the view name implicitly determined through
  a `RequestToViewNameTranslator` and the model implicitly enriched with command objects
  and the results of `@ModelAttribute` annotated reference data accessor methods.
* A `View` object, with the model implicitly determined through command objects and
  `@ModelAttribute` annotated reference data accessor methods. The handler method may
  also programmatically enrich the model by declaring a `Model` argument (see above).
* A `String` value which is interpreted as view name, with the model implicitly
  determined through command objects and `@ModelAttribute` annotated reference data
  accessor methods. The handler method may also programmatically enrich the model by
  declaring a `Model` argument (see above).
* `void` if the method handles the response itself (e.g. by writing the response content
  directly).
* Any other return type will be considered a single model attribute to be exposed to the
  view, using the attribute name specified through `@ModelAttribute` at the method level
  (or the default attribute name based on the return type's class name otherwise). The
  model will be implicitly enriched with command objects and the results of
  `@ModelAttribute` annotated reference data accessor methods.



[[portlet-ann-requestparam]]
==== Binding request parameters to method parameters with @RequestParam

The `@RequestParam` annotation is used to bind request parameters to a method parameter
in your controller.

The following code snippet from the PetPortal sample application shows the usage:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Controller
	@RequestMapping("EDIT")
	@SessionAttributes("site")
	public class PetSitesEditController {

		// ...

		public void removeSite(@RequestParam("site") String site, ActionResponse response) {
			this.petSites.remove(site);
			response.setRenderParameter("action", "list");
		}

		// ...

	}
----

Parameters using this annotation are required by default, but you can specify that a
parameter is optional by setting `@RequestParam`'s `required` attribute to `false`
(e.g., `@RequestParam(value="id", required=false)`).



[[portlet-ann-modelattrib]]
==== Providing a link to data from the model with @ModelAttribute

`@ModelAttribute` has two usage scenarios in controllers. When placed on a method
parameter, `@ModelAttribute` is used to map a model attribute to the specific, annotated
method parameter (see the `populateSite()` method below). This is how the controller
gets a reference to the object holding the data entered in the form. In addition, the
parameter can be declared as the specific type of the form backing object rather than as
a generic `java.lang.Object`, thus increasing type safety.

`@ModelAttribute` is also used at the method level to provide __reference data__ for the
model (see the `getPetSites()` method below). For this usage the method signature can
contain the same types as documented above for the `@RequestMapping` annotation.

[NOTE]
====
`@ModelAttribute` annotated methods will be executed __before__ the chosen
`@RequestMapping` annotated handler method. They effectively pre-populate the implicit
model with specific attributes, often loaded from a database. Such an attribute can then
already be accessed through `@ModelAttribute` annotated handler method parameters in the
chosen handler method, potentially with binding and validation applied to it.
====

The following code snippet shows these two usages of this annotation:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Controller
	@RequestMapping("EDIT")
	@SessionAttributes("site")
	public class PetSitesEditController {

		// ...

		@ModelAttribute("petSites")
		public Properties getPetSites() {
			return this.petSites;
		}

		@RequestMapping(params = "action=add") // action phase
		public void populateSite( @ModelAttribute("site") PetSite petSite, BindingResult result, SessionStatus status, ActionResponse response) {
			new PetSiteValidator().validate(petSite, result);
			if (!result.hasErrors()) {
				this.petSites.put(petSite.getName(), petSite.getUrl());
				status.setComplete();
				response.setRenderParameter("action", "list");
			}
		}
	}
----



[[portlet-ann-sessionattrib]]
==== Specifying attributes to store in a Session with @SessionAttributes

The type-level `@SessionAttributes` annotation declares session attributes used by a
specific handler. This will typically list the names of model attributes or types of
model attributes which should be transparently stored in the session or some
conversational storage, serving as form-backing beans between subsequent requests.

The following code snippet shows the usage of this annotation:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Controller
	@RequestMapping("EDIT")
	@SessionAttributes("site")
	public class PetSitesEditController {
		// ...
	}
----



[[portlet-ann-webdatabinder]]
==== Customizing WebDataBinder initialization

To customize request parameter binding with PropertyEditors, etc. via Spring's
`WebDataBinder`, you can either use `@InitBinder`-annotated methods within your
controller or externalize your configuration by providing a custom
`WebBindingInitializer`.


[[portlet-ann-initbinder]]
===== Customizing data binding with @InitBinder

Annotating controller methods with `@InitBinder` allows you to configure web data
binding directly within your controller class. `@InitBinder` identifies methods which
initialize the `WebDataBinder` which will be used for populating command and form object
arguments of annotated handler methods.

Such init-binder methods support all arguments that `@RequestMapping` supports, except
for command/form objects and corresponding validation result objects. Init-binder
methods must not have a return value. Thus, they are usually declared as `void`. Typical
arguments include `WebDataBinder` in combination with `WebRequest` or
`java.util.Locale`, allowing code to register context-specific editors.

The following example demonstrates the use of `@InitBinder` for configuring a
`CustomDateEditor` for all `java.util.Date` form properties.

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Controller
	public class MyFormController {

		@InitBinder
		public void initBinder(WebDataBinder binder) {
		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
			dateFormat.setLenient(false);
			binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
		}

		// ...

	}
----


[[portlet-ann-webbindinginitializer]]
===== Configuring a custom WebBindingInitializer

To externalize data binding initialization, you can provide a custom implementation of
the `WebBindingInitializer` interface, which you then enable by supplying a custom bean
configuration for an `AnnotationMethodHandlerAdapter`, thus overriding the default
configuration.




[[portlet-deployment]]
=== Portlet application deployment
The process of deploying a Spring Portlet MVC application is no different than deploying
any JSR-168 Portlet application. However, this area is confusing enough in general that
it is worth talking about here briefly.

Generally, the portal/portlet container runs in one webapp in your servlet container and
your portlets run in another webapp in your servlet container. In order for the portlet
container webapp to make calls into your portlet webapp it must make cross-context calls
to a well-known servlet that provides access to the portlet services defined in your
`portlet.xml` file.

The JSR-168 specification does not specify exactly how this should happen, so each
portlet container has its own mechanism for this, which usually involves some kind of
"deployment process" that makes changes to the portlet webapp itself and then registers
the portlets within the portlet container.

At a minimum, the `web.xml` file in your portlet webapp is modified to inject the
well-known servlet that the portlet container will call. In some cases a single servlet
will service all portlets in the webapp, in other cases there will be an instance of the
servlet for each portlet.

Some portlet containers will also inject libraries and/or configuration files into the
webapp as well. The portlet container must also make its implementation of the Portlet
JSP Tag Library available to your webapp.

The bottom line is that it is important to understand the deployment needs of your
target portal and make sure they are met (usually by following the automated deployment
process it provides). Be sure to carefully review the documentation from your portal for
this process.

Once you have deployed your portlet, review the resulting `web.xml` file for sanity.
Some older portals have been known to corrupt the definition of the
`ViewRendererServlet`, thus breaking the rendering of your portlets.



[[websocket]]
== WebSocket Support
This part of the reference documentation covers Spring Framework's support for
WebSocket-style messaging in web applications including use of STOMP as an
application level WebSocket sub-protocol.

<<websocket-intro>> establishes a frame of mind in which to think about
WebSocket, covering adoption challenges, design considerations, and thoughts on
when it is a good fit.

<<websocket-server>> reviews the Spring WebSocket API on the server-side, while
<<websocket-fallback>> explains the SockJS protocol and shows how to configure
and use it.

<<websocket-stomp-overview>> introduces the STOMP messaging protocol.
<<websocket-stomp-enable>> demonstrates how to configure STOMP support in Spring.
<<websocket-stomp-handle-annotations>> and the following sections explain how to
write annotated message handling methods, send messages, choose message broker
options, as well as work with the special "user" destinations. Finally,
<<websocket-stomp-testing>> lists three approaches to testing STOMP/WebSocket
applications.



[[websocket-intro]]
=== Introduction
The WebSocket protocol http://tools.ietf.org/html/rfc6455[RFC 6455] defines an important
new capability for web applications: full-duplex, two-way communication between client
and server. It is an exciting new capability on the heels of a long history of
techniques to make the web more interactive including Java Applets, XMLHttpRequest,
Adobe Flash, ActiveXObject, various Comet techniques, server-sent events, and others.

A proper introduction to the WebSocket protocol is beyond the scope of this
document. At a minimum however it's important to understand that HTTP is used only for
the initial handshake, which relies on a mechanism built into HTTP to request
a protocol upgrade (or in this case a protocol switch) to which the server can respond with
HTTP status 101 (switching protocols) if it agrees. Assuming the handshake succeeds
the TCP socket underlying the HTTP upgrade request remains open and both client and
server can use it to send messages to each other.

Spring Framework 4 includes a new `spring-websocket` module with comprehensive
WebSocket support. It is compatible with the Java WebSocket API standard
(http://jcp.org/en/jsr/detail?id=356[JSR-356])
and also provides additional value-add as explained in the rest of the introduction.



[[websocket-into-fallback-options]]
==== WebSocket Fallback Options
An important challenge to adoption is the lack of support for WebSocket in some
browsers. Notably the first Internet Explorer version to support WebSocket is
version 10 (see http://caniuse.com/websockets for support by browser versions).
Furthermore, some restrictive proxies may be configured in ways that either
preclude the attempt to do an HTTP upgrade or otherwise break connection after
some time because it has remained opened for too long. A good overview on this
topic from Peter Lubbers is available in the InfoQ article
http://www.infoq.com/articles/Web-Sockets-Proxy-Servers["How HTML5 Web Sockets Interact With Proxy Servers"].

Therefore to build a WebSocket application today, fallback options are required in
order to simulate the WebSocket API where necessary. The Spring Framework provides
such transparent fallback options based on the https://github.com/sockjs/sockjs-protocol[SockJS protocol].
These options can be enabled through configuration and do not require modifying the
application otherwise.



[[websocket-intro-architecture]]
==== A Messaging Architecture
Aside from short-to-midterm adoption challenges, using WebSocket
brings up important design considerations that are important to recognize
early on, especially in contrast to what we know about building web applications today.

Today REST is a widely accepted, understood, and supported
architecture for building web applications. It is an architecture that relies
on having many URLs (__nouns__), a handful of HTTP methods (__verbs__), and
other principles such as using hypermedia (__links__), remaining stateless, etc.

By contrast a WebSocket application may use a single URL only for the
initial HTTP handshake. All messages thereafter share and flow on the
same TCP connection. This points to an entirely different, asynchronous,
event-driven, messaging architecture. One that is much closer
to traditional messaging applications (e.g. JMS, AMQP).

Spring Framework 4 includes a new `spring-messaging` module with key
abstractions from the
http://projects.spring.io/spring-integration/[Spring Integration] project
such as `Message`, `MessageChannel`, `MessageHandler`, and others that can serve as
a foundation for such a messaging architecture. The module also includes a
set of annotations for mapping messages to methods, similar to the Spring MVC
annotation based programming model.



[[websocket-intro-sub-protocol]]
==== Sub-Protocol Support in WebSocket
WebSocket does imply a __messaging architecture__ but does not mandate the
use of any specific __messaging protocol__. It is a very thin layer over TCP
that transforms a stream of bytes into a stream of messages
(either text or binary) and not much more. It is up to applications
to interpret the meaning of a message.

Unlike HTTP, which is an application-level protocol, in the WebSocket protocol
there is simply not enough information in an incoming message for a framework
or container to know how to route it or process it. Therefore WebSocket is arguably
too low level for anything but a very trivial application. It can be done, but
it will likely lead to creating a framework on top. This is comparable to how
most web applications today are written using a web framework rather than the
Servlet API alone.

For this reason the WebSocket RFC defines the use of
http://tools.ietf.org/html/rfc6455#section-1.9[sub-protocols].
During the handshake, the client and server can use the header
`Sec-WebSocket-Protocol` to agree on a sub-protocol, i.e. a higher, application-level
protocol to use. The use of a sub-protocol is not required, but
even if not used, applications will still need to choose a message
format that both the client and server can understand. That format can be custom,
framework-specific, or a standard messaging protocol.

The Spring Framework provides support for using
http://stomp.github.io/stomp-specification-1.2.html#Abstract[STOMP] -- a simple, messaging protocol
originally created for use in scripting languages with frames inspired
by HTTP. STOMP is widely supported and well suited for use over
WebSocket and over the web.



[[websocket-intro-when-to-use]]
==== Should I Use WebSocket?
With all the design considerations surrounding the use of WebSocket, it is
reasonable to ask, "When is it appropriate to use?".

The best fit for WebSocket is in web applications where the client and
server need to exchange events at high frequency and with low latency. Prime
candidates include, but are not limited to, applications in finance, games,
collaboration, and others. Such applications are both very sensitive to time
delays and also need to exchange a wide variety of messages at a high
frequency.

For other application types, however, this may not be the case.
For example, a news or social feed that shows breaking news as it becomes
available may be perfectly okay with simple polling once every few minutes.
Here latency is important, but it is acceptable if the news takes a
few minutes to appear.

Even in cases where latency is crucial, if the volume of messages is
relatively low (e.g. monitoring network failures) the use of
https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates[long polling]
should be considered as a relatively simple alternative that
works reliably and is comparable in terms of efficiency (again assuming the volume of
messages is relatively low).

It is the combination of both low latency and high frequency of messages that can make
the use of the WebSocket protocol critical. Even in such applications,
the choice remains whether all client-server
communication should be done through WebSocket messages as opposed to using
HTTP and REST. The answer is going to vary by application; however, it is likely
that some functionality may be exposed over both WebSocket and as a REST API in
order to provide clients with alternatives. Furthermore, a REST API call may need
to broadcast a message to interested clients connected via WebSocket.

The Spring Framework allows `@Controller` and `@RestController` classes to have both
HTTP request handling and WebSocket message handling methods.
Furthermore, a Spring MVC request handling method, or any application
method for that matter, can easily broadcast a message to all interested
WebSocket clients or to a specific user.




[[websocket-server]]
=== WebSocket API
The Spring Framework provides a WebSocket API designed to adapt to various WebSocket engines.
Currently the list includes WebSocket runtimes such as Tomcat 7.0.47+, Jetty 9.1+,
GlassFish 4.1+, WebLogic 12.1.3+, and Undertow 1.0+ (and WildFly 8.0+). Additional support
may be added as more WebSocket runtimes become available.

[NOTE]
====
As explained in the <<websocket-intro-sub-protocol,introduction>>, direct use of a
WebSocket API is too low level for applications -- until assumptions are made about the
format of a message there is little a framework can do to interpret messages or route
them via annotations. This is why applications should consider using a sub-protocol
and Spring's <<websocket-stomp,STOMP over WebSocket>> support.

When using a higher level protocol, the details of the WebSocket API become less
relevant, much like the details of TCP communication are not exposed to applications
when using HTTP. Nevertheless this section covers the details of using WebSocket
directly.
====



[[websocket-server-handler]]
==== Create and Configure a WebSocketHandler
Creating a WebSocket server is as simple as implementing `WebSocketHandler` or more
likely extending either `TextWebSocketHandler` or `BinaryWebSocketHandler`:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	import org.springframework.web.socket.WebSocketHandler;
	import org.springframework.web.socket.WebSocketSession;
	import org.springframework.web.socket.TextMessage;

	public class MyHandler extends TextWebSocketHandler {

		@Override
		public void handleTextMessage(WebSocketSession session, TextMessage message) {
			// ...
		}

	}
----

There is dedicated WebSocket Java-config and XML namespace support for mapping the above
WebSocket handler to a specific URL:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	import org.springframework.web.socket.config.annotation.EnableWebSocket;
	import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
	import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

	@Configuration
	@EnableWebSocket
	public class WebSocketConfig implements WebSocketConfigurer {

		@Override
		public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
			registry.addHandler(myHandler(), "/myHandler");
		}

		@Bean
		public WebSocketHandler myHandler() {
			return new MyHandler();
		}

	}
----

XML configuration equivalent:

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			http://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			http://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:handlers>
			<websocket:mapping path="/myHandler" handler="myHandler"/>
		</websocket:handlers>

		<bean id="myHandler" class="org.springframework.samples.MyHandler"/>

	</beans>
----

The above is for use in Spring MVC applications and should be included in the
configuration of a <<mvc-serlvet,DispatcherServlet>>. However, Spring's WebSocket
support does not depend on Spring MVC. It is relatively simple to integrate a `WebSocketHandler`
into other HTTP serving environments with the help of
{javadoc-baseurl}/org/springframework/web/socket/server/support/WebSocketHttpRequestHandler.html[WebSocketHttpRequestHandler].



[[websocket-server-handshake]]
==== Customizing the WebSocket Handshake
The easiest way to customize the initial HTTP WebSocket handshake request is through
a `HandshakeInterceptor`, which exposes "before" and "after" the handshake methods.
Such an interceptor can be used to preclude the handshake or to make any attributes
available to the `WebSocketSession`. For example, there is a built-in interceptor
for passing HTTP session attributes to the WebSocket session:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocket
	public class WebSocketConfig implements WebSocketConfigurer {

		@Override
		public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
			registry.addHandler(new MyHandler(), "/myHandler")
				.addInterceptors(new HttpSessionHandshakeInterceptor());
		}

	}
----

And the XML configuration equivalent:

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			http://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			http://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:handlers>
			<websocket:mapping path="/myHandler" handler="myHandler"/>
			<websocket:handshake-interceptors>
				<bean class="org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor"/>
			</websocket:handshake-interceptors>
		</websocket:handlers>

		<bean id="myHandler" class="org.springframework.samples.MyHandler"/>

	</beans>
----

A more advanced option is to extend the `DefaultHandshakeHandler` that performs
the steps of the WebSocket handshake, including validating the client origin,
negotiating a sub-protocol, and others. An application may also need to use this
option if it needs to configure a custom `RequestUpgradeStrategy` in order to
adapt to a WebSocket server engine and version that is not yet supported
(also see <<websocket-server-deployment>> for more on this subject).
Both the Java-config and XML namespace make it possible to configure a custom
`HandshakeHandler`.



[[websocket-server-decorators]]
==== WebSocketHandler Decoration
Spring provides a `WebSocketHandlerDecorator` base class that can be used to decorate
a `WebSocketHandler` with additional behavior. Logging and exception handling
implementations are provided and added by default when using the WebSocket Java-config
or XML namespace. The `ExceptionWebSocketHandlerDecorator` catches all uncaught
exceptions arising from any WebSocketHandler method and closes the WebSocket
session with status `1011` that indicates a server error.



[[websocket-server-deployment]]
==== Deployment Considerations
The Spring WebSocket API is easy to integrate into a Spring MVC application where
the `DispatcherServlet` serves both HTTP WebSocket handshake as well as other
HTTP requests. It is also easy to integrate into other HTTP processing scenarios
by invoking `WebSocketHttpRequestHandler`. This is convenient and easy to
understand. However, special considerations apply with regards to JSR-356 runtimes.

The Java WebSocket API (JSR-356) provides two deployment mechanisms. The first
involves a Servlet container classpath scan (Servlet 3 feature) at startup; and
the other is a registration API to use at Servlet container initialization.
Neither of these mechanism makes it possible to use a single "front controller"
for all HTTP processing -- including WebSocket handshake and all other HTTP
requests -- such as Spring MVC's `DispatcherServlet`.

This is a significant limitation of JSR-356 that Spring's WebSocket support
addresses by providing a server-specific `RequestUpgradeStrategy` even when
running in a JSR-356 runtime.

[NOTE]
====
A request to overcome the above limitation in the Java WebSocket API has been
created and can be followed at
https://java.net/jira/browse/WEBSOCKET_SPEC-211[WEBSOCKET_SPEC-211].
Also note that Tomcat and Jetty already provide native API alternatives that
makes it easy to overcome the limitation. We are hopeful that more servers
will follow their example regardless of when it is addressed in the
Java WebSocket API.
====

A secondary consideration is that Servlet containers with JSR-356 support are expected
to perform a `ServletContainerInitializer` (SCI) scan that can slow down application
startup, in some cases dramatically. If a significant impact is observed after an
upgrade to a Servlet container version with JSR-356 support, it should
be possible to selectively enable or disable web fragments (and SCI scanning)
through the use of the `<absolute-ordering />` element in `web.xml`:

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<web-app xmlns="http://java.sun.com/xml/ns/javaee"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="
			http://java.sun.com/xml/ns/javaee
			http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
		version="3.0">

		<absolute-ordering/>

	</web-app>
----

You can then selectively enable web fragments by name, such as Spring's own
`SpringServletContainerInitializer` that provides support for the Servlet 3
Java initialization API, if required:

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<web-app xmlns="http://java.sun.com/xml/ns/javaee"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="
			http://java.sun.com/xml/ns/javaee
			http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
		version="3.0">

		<absolute-ordering>
			<name>spring_web</name>
		</absolute-ordering>

	</web-app>
----

[[websocket-server-runtime-configuration]]
==== Configuring the WebSocket Engine

Each underlying WebSocket engine exposes configuration properties that control
runtime characteristics such as the size of message buffer sizes, idle timeout,
and others.

For Tomcat, WildFly, and GlassFish add a `ServletServerContainerFactoryBean` to your
WebSocket Java config:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocket
	public class WebSocketConfig implements WebSocketConfigurer {

		@Bean
		public ServletServerContainerFactoryBean createWebSocketContainer() {
			ServletServerContainerFactoryBean container = new ServletServerContainerFactoryBean();
			container.setMaxTextMessageBufferSize(8192);
			container.setMaxBinaryMessageBufferSize(8192);
			return container;
		}

	}
----

or WebSocket XML namespace:

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			http://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			http://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<bean class="org.springframework...ServletServerContainerFactoryBean">
			<property name="maxTextMessageBufferSize" value="8192"/>
			<property name="maxBinaryMessageBufferSize" value="8192"/>
		</bean>

	</beans>
----

[NOTE]
====
For client side WebSocket configuration, you should use `WebSocketContainerFactoryBean`
(XML) or `ContainerProvider.getWebSocketContainer()` (Java config).
====

For Jetty, you'll need to supply a pre-configured Jetty `WebSocketServerFactory` and plug
that into Spring's `DefaultHandshakeHandler` through your WebSocket Java config:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocket
	public class WebSocketConfig implements WebSocketConfigurer {

		@Override
		public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
			registry.addHandler(echoWebSocketHandler(),
				"/echo").setHandshakeHandler(handshakeHandler());
		}

		@Bean
		public DefaultHandshakeHandler handshakeHandler() {

			WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);
			policy.setInputBufferSize(8192);
			policy.setIdleTimeout(600000);

			return new DefaultHandshakeHandler(
					new JettyRequestUpgradeStrategy(new WebSocketServerFactory(policy)));
		}

	}
----

or WebSocket XML namespace:

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			http://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			http://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:handlers>
			<websocket:mapping path="/echo" handler="echoHandler"/>
			<websocket:handshake-handler ref="handshakeHandler"/>
		</websocket:handlers>

		<bean id="handshakeHandler" class="org.springframework...DefaultHandshakeHandler">
			<constructor-arg ref="upgradeStrategy"/>
		</bean>

		<bean id="upgradeStrategy" class="org.springframework...JettyRequestUpgradeStrategy">
			<constructor-arg ref="serverFactory"/>
		</bean>

		<bean id="serverFactory" class="org.eclipse.jetty...WebSocketServerFactory">
			<constructor-arg>
				<bean class="org.eclipse.jetty...WebSocketPolicy">
					<constructor-arg value="SERVER"/>
					<property name="inputBufferSize" value="8092"/>
					<property name="idleTimeout" value="600000"/>
				</bean>
			</constructor-arg>
		</bean>

	</beans>
----

[[websocket-server-allowed-origins]]
==== Configuring allowed origins

As of Spring Framework 4.1.5, the default behavior for WebSocket and SockJS is to accept
only _same origin_ requests. It is also possible to allow _all_ or a specified list of origins.
This check is mostly designed for browser clients. There is nothing preventing other types
of clients from modifying the `Origin` header value (see
https://tools.ietf.org/html/rfc6454[RFC 6454: The Web Origin Concept] for more details).

The 3 possible behaviors are:

 * Allow only same origin requests (default): in this mode, when SockJS is enabled, the
   Iframe HTTP response header `X-Frame-Options` is set to `SAMEORIGIN`, and JSONP
   transport is disabled since it does not allow to check the origin of a request.
   As a consequence, IE6 and IE7 are not supported when this mode is enabled.
 * Allow a specified list of origins: each provided _allowed origin_ must start with `http://`
   or `https://`. In this mode, when SockJS is enabled, both IFrame and JSONP based
   transports are disabled. As a consequence, IE6 through IE9 are not supported when this
   mode is enabled.
 * Allow all origins: to enable this mode, you should provide `{asterisk}` as the allowed origin
   value. In this mode, all transports are available.

WebSocket and SockJS allowed origins can be configured as shown bellow:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	import org.springframework.web.socket.config.annotation.EnableWebSocket;
	import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
	import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

	@Configuration
	@EnableWebSocket
	public class WebSocketConfig implements WebSocketConfigurer {

		@Override
		public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
			registry.addHandler(myHandler(), "/myHandler").setAllowedOrigins("http://mydomain.com");
		}

		@Bean
		public WebSocketHandler myHandler() {
			return new MyHandler();
		}

	}
----

XML configuration equivalent:

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			http://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			http://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:handlers allowed-origins="http://mydomain.com">
			<websocket:mapping path="/myHandler" handler="myHandler" />
		</websocket:handlers>

		<bean id="myHandler" class="org.springframework.samples.MyHandler"/>

	</beans>
----


[[websocket-fallback]]
=== SockJS Fallback Options
As explained in the <<websocket-into-fallback-options,introduction>>, WebSocket is not
supported in all browsers yet and may be precluded by restrictive network proxies.
This is why Spring provides fallback options that emulate the WebSocket API as close
as possible based on the https://github.com/sockjs/sockjs-protocol[SockJS protocol]
(version 0.3.3).

[[websocket-fallback-sockjs-overview]]
==== Overview of SockJS

The goal of SockJS is to let applications use a WebSocket API but fall back to
non-WebSocket alternatives when necessary at runtime, i.e. without the need to
change application code.

SockJS consists of:

* The https://github.com/sockjs/sockjs-protocol[SockJS protocol]
defined in the form of executable
http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html[narrated tests].
* The https://github.com/sockjs/sockjs-client/tree/v0.3.4[SockJS JavaScript client] - a client library for use in browsers.
* SockJS server implementations including one in the Spring Framework `spring-websocket` module.
* As of 4.1 `spring-websocket` also provides a SockJS Java client.

SockJS is designed for use in browsers. It goes to great lengths
to support a wide range of browser versions using a variety of techniques.
For the full list of SockJS transport types and browsers see the
https://github.com/sockjs/sockjs-client/tree/v0.3.4[SockJS client] page. Transports
fall in 3 general categories: WebSocket, HTTP Streaming, and HTTP Long Polling.
For an overview of these categories see
https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/[this blog post].

The SockJS client begins by sending `"GET /info"` to
obtain basic information from the server. After that it must decide what transport
to use. If possible WebSocket is used. If not, in most browsers
there is at least one HTTP streaming option and if not then HTTP (long)
polling is used.

All transport requests have the following URL structure:
----
http://host:port/myApp/myEndpoint/{server-id}/{session-id}/{transport}
----

* `{server-id}` - useful for routing requests in a cluster but not used otherwise.
* `{session-id}` - correlates HTTP requests belonging to a SockJS session.
* `{transport}` - indicates the transport type, e.g. "websocket", "xhr-streaming", etc.

The WebSocket transport needs only a single HTTP request to do the WebSocket handshake.
All messages thereafter are exchanged on that socket.

HTTP transports require more requests. Ajax/XHR streaming for example relies on
one long-running request for server-to-client messages and additional HTTP POST
requests for client-to-server messages. Long polling is similar except it
ends the current request after each server-to-client send.

SockJS adds minimal message framing. For example the server sends the letter +o+
("open" frame) initially, messages are sent as +a["message1","message2"]+
(JSON-encoded array), the letter +h+ ("heartbeat" frame) if no messages flow
for 25 seconds by default, and the letter +c+ ("close" frame) to close the session.

To learn more, run an example in a browser and watch the HTTP requests.
The SockJS client allows fixing the list of transports so it is possible to
see each transport one at a time. The SockJS client also provides a debug flag
which enables helpful messages in the browser console. On the server side enable
`TRACE` logging for `org.springframework.web.socket`.
For even more detail refer to the SockJS protocol
http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html[narrated test].


[[websocket-fallback-sockjs-enable]]
==== Enable SockJS
SockJS is easy to enable through Java configuration:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocket
	public class WebSocketConfig implements WebSocketConfigurer {

		@Override
		public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
			registry.addHandler(myHandler(), "/myHandler").withSockJS();
		}

		@Bean
		public WebSocketHandler myHandler() {
			return new MyHandler();
		}

	}
----

and the XML configuration equivalent:

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			http://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			http://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:handlers>
			<websocket:mapping path="/myHandler" handler="myHandler"/>
			<websocket:sockjs/>
		</websocket:handlers>

		<bean id="myHandler" class="org.springframework.samples.MyHandler"/>

	</beans>
----

The above is for use in Spring MVC applications and should be included in the
configuration of a <<mvc-serlvet,DispatcherServlet>>. However, Spring's WebSocket
and SockJS support does not depend on Spring MVC. It is relatively simple to
integrate into other HTTP serving environments with the help of
{javadoc-baseurl}/org/springframework/web/socket/sockjs/support/SockJsHttpRequestHandler.html[SockJsHttpRequestHandler].

On the browser side, applications can use the
https://github.com/sockjs/sockjs-client/tree/v0.3.4[sockjs-client] (version 0.3.x) that
emulates the W3C WebSocket API and communicates with the server to select the best
transport option depending on the browser it's running in. Review the
https://github.com/sockjs/sockjs-client/tree/v0.3.4[sockjs-client] page and the list of
transport types supported by browser. The client also provides several
configuration options, for example, to specify which transports to include.

[[websocket-fallback-xhr-vs-iframe]]
==== HTTP Streaming in IE 8, 9: Ajax/XHR vs IFrame

Internet Explorer 8 and 9 are and will remain common for some time. They are
a key reason for having SockJS. This section covers important
considerations about running in those browsers.

The SockJS client supports Ajax/XHR streaming in IE 8 and 9 via Microsoft's
http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx[XDomainRequest].
That works across domains but does not support sending cookies.
Cookies are very often essential for Java applications.
However since the SockJS client can be used with many server
types (not just Java ones), it needs to know whether cookies matter.
If so the SockJS client prefers Ajax/XHR for streaming or otherwise it
relies on a iframe-based technique.

The very first `"/info"` request from the SockJS client is a request for
information that can influence the client's choice of transports.
One of those details is whether the server application relies on cookies,
e.g. for authentication purposes or clustering with sticky sessions.
Spring's SockJS support includes a property called `sessionCookieNeeded`.
It is enabled by default since most Java applications rely on the `JSESSIONID`
cookie. If your application does not need it, you can turn off this option
and the SockJS client should choose `xdr-streaming` in IE 8 and 9.

If you do use an iframe-based transport, and in any case, it is good to know
that browsers can be instructed to block the use of IFrames on a given page by
setting the HTTP response header `X-Frame-Options` to `DENY`,
`SAMEORIGIN`, or `ALLOW-FROM <origin>`. This is used to prevent
https://www.owasp.org/index.php/Clickjacking[clickjacking].

[NOTE]
====
Spring Security 3.2+ provides support for setting `X-Frame-Options` on every
response. By default the Spring Security Java config sets it to `DENY`.
In 3.2 the Spring Security XML namespace does not set that header by default
but may be configured to do so, and in the future it may set it by default.

See http://docs.spring.io/spring-security/site/docs/3.2.2.RELEASE/reference/htmlsingle/#headers[Section 7.1. "Default Security Headers"]
of the Spring Security documentation for details on how to configure the
setting of the `X-Frame-Options` header. You may also check or watch
https://jira.spring.io/browse/SEC-2501[SEC-2501] for additional background.
====

If your application adds the `X-Frame-Options` response header (as it should!)
and relies on an iframe-based transport, you will need to set the header value to
`SAMEORIGIN` or `ALLOW-FROM <origin>`. Along with that the Spring SockJS
support also needs to know the location of the SockJS client because it is loaded
from the iframe. By default the iframe is set to download the SockJS client
from a CDN location. It is a good idea to configure this option to
a URL from the same origin as the application.

In Java config this can be done as shown below. The XML namespace provides a
similar option via the `<websocket:sockjs>` element:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocket
	public class WebSocketConfig implements WebSocketConfigurer {

		@Override
		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry.addEndpoint("/portfolio").withSockJS()
					.setClientLibraryUrl("http://localhost:8080/myapp/js/sockjs-client.js");
		}

		// ...

	}
----

[NOTE]
====
During initial development, do enable the SockJS client `devel` mode that prevents
the browser from caching SockJS requests (like the iframe) that would otherwise
be cached. For details on how to enable it see the
https://github.com/sockjs/sockjs-client/tree/v0.3.4[SockJS client] page.
====

[[websocket-fallback-sockjs-heartbeat]]
==== Heartbeat Messages

The SockJS protocol requires servers to send heartbeat messages to preclude proxies
from concluding a connection is hung. The Spring SockJS configuration has a property
called `heartbeatTime` that can be used to customize the frequency. By default a
heartbeat is sent after 25 seconds assuming no other messages were sent on that
connection. This 25 seconds value is in line with the following
http://tools.ietf.org/html/rfc6202[IETF recommendation] for public Internet applications.

[NOTE]
====
When using STOMP over WebSocket/SockJS, if the STOMP client and server negotiate
heartbeats to be exchanged, the SockJS heartbeats are disabled.
====

The Spring SockJS support also allows configuring the `TaskScheduler` to use
for scheduling heartbeats tasks. The task scheduler is backed by a thread pool
with default settings based on the number of available processors. Applications
should consider customizing the settings according to their specific needs.

[[websocket-fallback-sockjs-servlet3-async]]
==== Servlet 3 Async Requests

HTTP streaming and HTTP long polling SockJS transports require a connection to remain
open longer than usual. For an overview of these techniques see
https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/[this blog post].

In Servlet containers this is done through Servlet 3 async support that
allows exiting the Servlet container thread processing a request and continuing
to write to the response from another thread.

A specific issue is that the Servlet API does not provide notifications for a client
that has gone away, see https://java.net/jira/browse/SERVLET_SPEC-44[SERVLET_SPEC-44].
However, Servlet containers raise an exception on subsequent attempts to write
to the response. Since Spring's SockJS Service supports sever-sent heartbeats (every
25 seconds by default), that means a client disconnect is usually detected within that
time period or earlier if messages are sent more frequently.

[NOTE]
====
As a result network IO failures may occur simply because a client has disconnected, which
can fill the log with unnecessary stack traces. Spring makes a best effort to identify
such network failures that represent client disconnects (specific to each server) and log
a minimal message using the dedicated log category `DISCONNECTED_CLIENT_LOG_CATEGORY`
defined in `AbstractSockJsSession`. If you need to see the stack traces, set that
log category to TRACE.
====

[[websocket-fallback-cors]]
==== CORS Headers for SockJS

If you allow cross-origin requests (see <<websocket-server-allowed-origins>>), the SockJS protocol
uses CORS for cross-domain support in the XHR streaming and polling transports. Therefore
CORS headers are added automatically unless the presence of CORS headers in the response
is detected. So if an application is already configured to provide CORS support, e.g.
through a Servlet Filter, Spring's SockJsService will skip this part.

It is also possible to disable the addition of these CORS headers via the
`suppressCors` property in Spring's SockJsService.

The following is the list of headers and values expected by SockJS:

* `"Access-Control-Allow-Origin"` - initialized from the value of the "Origin" request header.
* `"Access-Control-Allow-Credentials"` - always set to `true`.
* `"Access-Control-Request-Headers"` - initialized from values from the equivalent request header.
* `"Access-Control-Allow-Methods"` - the HTTP methods a transport supports (see `TransportType` enum).
* `"Access-Control-Max-Age"` - set to 31536000 (1 year).

For the exact implementation see `addCorsHeaders` in `AbstractSockJsService` as well
as the `TransportType` enum in the source code.

Alternatively if the CORS configuration allows it consider excluding URLs with the
SockJS endpoint prefix thus letting Spring's `SockJsService` handle it.


[[websocket-fallback-sockjs-client]]
==== SockJS Client

A SockJS Java client is provided in order to connect to remote SockJS endpoints without
using a browser. This can be especially useful when there is a need for bidirectional
communication between 2 servers over a public network, i.e. where network proxies may
preclude the use of the WebSocket protocol. A SockJS Java client is also very useful
for testing purposes, for example to simulate a large number of concurrent users.

The SockJS Java client supports the "websocket", "xhr-streaming", and "xhr-polling"
transports. The remaining ones only make sense for use in a browser.

The `WebSocketTransport` can be configured with:

* `StandardWebSocketClient` in a JSR-356 runtime
* `JettyWebSocketClient` using the Jetty 9+ native WebSocket API
* Any implementation of Spring's `WebSocketClient`

An `XhrTransport` by definition supports both "xhr-streaming" and "xhr-polling" since
from a client perspective there is no difference other than in the URL used to connect
to the server. At present there are two implementations:

* `RestTemplateXhrTransport` uses Spring's `RestTemplate` for HTTP requests.
* `JettyXhrTransport` uses Jetty's `HttpClient` for HTTP requests.

The example below shows how to create a SockJS client and connect to a SockJS endpoint:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
  List<Transport> transports = new ArrayList<>(2);
  transports.add(new WebSocketTransport(StandardWebSocketClient()));
  transports.add(new RestTemplateXhrTransport());

  SockJsClient sockJsClient = new SockJsClient(transports);
  sockJsClient.doHandshake(new MyWebSocketHandler(), "ws://example.com:8080/sockjs");
----

[NOTE]
====
SockJS uses JSON formatted arrays for messages. By default Jackson 2 is used and needs
to be on the classpath. Alternatively you can configure a custom implementation of
`SockJsMessageCodec` and configure it on the `SockJsClient`.
====

To use the SockJsClient for simulating a large number of concurrent users you will
need to configure the underlying HTTP client (for XHR transports) to allow a sufficient
number of connections and threads. For example with Jetty:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
HttpClient jettyHttpClient = new HttpClient();
jettyHttpClient.setMaxConnectionsPerDestination(1000);
jettyHttpClient.setExecutor(new QueuedThreadPool(1000));
----

Consider also customizing these server-side SockJS related properties (see Javadoc for details):

[source,java,indent=0]
[subs="verbatim,quotes"]
----
@Configuration
public class WebSocketConfig extends WebSocketMessageBrokerConfigurationSupport {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/sockjs").withSockJS()
            .setStreamBytesLimit(512 * 1024)
            .setHttpMessageCacheSize(1000)
            .setDisconnectDelay(30 * 1000);
    }

    // ...

}
----




[[websocket-stomp]]
=== STOMP Over WebSocket Messaging Architecture
The WebSocket protocol defines two main types of messages -- text and binary --
but leaves their content undefined. Instead it's expected that the client and
server may agree on using a sub-protocol, i.e. a higher-level protocol that defines
the message content. Using a sub-protocol is optional but either way the client
and server both need to understand how to interpret messages.



[[websocket-stomp-overview]]
==== Overview of STOMP
http://stomp.github.io/stomp-specification-1.2.html#Abstract[STOMP] is a simple
text-oriented messaging protocol that was originally created for scripting languages
(such as Ruby, Python, and Perl) to connect to enterprise message brokers. It is
designed to address a subset of commonly used patterns in messaging protocols. STOMP
can be used over any reliable 2-way streaming network protocol such as TCP and WebSocket.

STOMP is a frame based protocol with frames modeled on HTTP. This is the
structure of a frame:

----
COMMAND
header1:value1
header2:value2

Body^@
----

For example, a client can use the +SEND+ command to send a message or the
+SUBSCRIBE+ command to express interest in receiving messages. Both of these commands
require a +"destination"+ header that indicates where to send a message, or likewise
what to subscribe to.

Here is an example of a client sending a request to buy stock shares:

----
SEND
destination:/queue/trade
content-type:application/json
content-length:44

{"action":"BUY","ticker":"MMM","shares",44}^@
----

Here is an example of a client subscribing to receive stock quotes:
----
SUBSCRIBE
id:sub-1
destination:/topic/price.stock.*

^@
----

[NOTE]
====
The meaning of a destination is intentionally left opaque in the STOMP spec. It can
be any string, and it's entirely up to STOMP servers to define the semantics and
the syntax of the destinations that they support. It is very common, however, for
destinations to be path-like strings where `"/topic/.."` implies publish-subscribe
(__one-to-many__) and `"/queue/"` implies point-to-point (__one-to-one__) message
exchanges.
====

STOMP servers can use the +MESSAGE+ command to broadcast messages to all subscribers.
Here is an example of a server sending a stock quote to a subscribed client:

----
MESSAGE
message-id:nxahklf6-1
subscription:sub-1
destination:/topic/price.stock.MMM

{"ticker":"MMM","price":129.45}^@
----

[NOTE]
====
It is important to know that a server cannot send unsolicited messages. All messages
from a server must be in response to a specific client subscription, and the
+"subscription-id"+ header of the server message must match the +"id"+ header of the
client subscription.
====

The above overview is intended to provide the most basic understanding of the
STOMP protocol. It is recommended to review the protocol
http://stomp.github.io/stomp-specification-1.2.html[specification], which is
easy to follow and manageable in terms of size.

The following summarizes the benefits for an application of using STOMP over WebSocket:

* Standard message format
* Application-level protocol with support for common messaging patterns
* Client-side support, e.g. https://github.com/jmesnil/stomp-websocket[stomp.js], https://github.com/cujojs/msgs[msgs.js]
* The ability to interpret, route, and process messages on both the client and server-side
* The option to plug in a message broker -- RabbitMQ, ActiveMQ, many others -- to broadcast messages (explained later)

Most importantly the use of STOMP (vs plain WebSocket) enables the Spring Framework
to provide a programming model for application-level use in the same way that
Spring MVC provides a programming model based on HTTP.



[[websocket-stomp-enable]]
==== Enable STOMP over WebSocket
The Spring Framework provides support for using STOMP over WebSocket through
the +spring-messaging+ and +spring-websocket+ modules. It's easy to enable it.

Here is an example of configuring a STOMP WebSocket endpoint with SockJS fallback
options. The endpoint is available for clients to connect to a URL path `/app/portfolio`:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
	import org.springframework.web.socket.config.annotation.StompEndpointRegistry;

	@Configuration
	@EnableWebSocketMessageBroker
	public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

		@Override
        public void configureMessageBroker(MessageBrokerRegistry config) {
            config.setApplicationDestinationPrefixes("/app");
            config.enableSimpleBroker("/queue", "/topic");
        }

		@Override
		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry.addEndpoint("/portfolio").withSockJS();
		}

		// ...

	}
----

XML configuration equivalent:

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			http://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			http://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:message-broker application-destination-prefix="/app">
			<websocket:stomp-endpoint path="/portfolio">
				<websocket:sockjs/>
			</websocket:stomp-endpoint>
			<websocket:simple-broker prefix="/queue, /topic"/>
			...
		</websocket:message-broker>

	</beans>
----

On the browser side, a client might connect as follows using
https://github.com/jmesnil/stomp-websocket[stomp.js] and the
https://github.com/sockjs/sockjs-client[sockjs-client]:

[source,javascript,indent=0]
[subs="verbatim,quotes"]
----
	var socket = new SockJS("/spring-websocket-portfolio/portfolio");
	var stompClient = Stomp.over(socket);

	stompClient.connect({}, function(frame) {
	}
----

Or if connecting via WebSocket (without SockJS):

[source,javascript,indent=0]
[subs="verbatim,quotes"]
----
	var socket = new WebSocket("/spring-websocket-portfolio/portfolio");
	var stompClient = Stomp.over(socket);

	stompClient.connect({}, function(frame) {
	}
----

Note that the `stompClient` above does not need to specify `login` and `passcode` headers.
Even if it did, they would be ignored, or rather overridden, on the server side. See the
sections <<websocket-stomp-handle-broker-relay-configure>> and
<<websocket-stomp-authentication>> for more information on authentication.


[[websocket-stomp-message-flow]]
==== Flow of Messages

When a STOMP endpoint is configured, the Spring application acts as the STOMP broker
to connected clients. It handles incoming messages and sends messages back.
This section provides a big picture overview of how messages flow inside the application.

The `spring-messaging` module contains a number of abstractions that originated in the
https://spring.io/spring-integration[Spring Integration] project and are intended
for use as building blocks in messaging applications:

* {javadoc-baseurl}/org/springframework/messaging/Message.html[Message] --
a message with headers and a payload.
* {javadoc-baseurl}/org/springframework/messaging/MessageHandler.html[MessageHandler] --
a contract for handling a message.
* {javadoc-baseurl}/org/springframework/messaging/MessageChannel.html[MessageChannel] --
a contract for sending a message enabling loose coupling between senders and receivers.
* {javadoc-baseurl}/org/springframework/messaging/SubscribableChannel.html[SubscribableChannel] --
extends `MessageChannel` and sends messages to registered `MessageHandler` subscribers.
* {javadoc-baseurl}/org/springframework/messaging/support/ExecutorSubscribableChannel.html[ExecutorSubscribableChannel] --
a concrete implementation of `SubscribableChannel` that can deliver messages
asynchronously via a thread pool.

The provided STOMP over WebSocket config, both Java and XML, uses the above to
assemble a concrete message flow including the following 3 channels:

* `"clientInboundChannel"` -- for messages from WebSocket clients. Every incoming
WebSocket message carrying a STOMP frame is sent through this channel.
* `"clientOutboundChannel"` -- for messages to WebSocket clients. Every outgoing
STOMP message from the broker is sent through this channel before getting sent
to a client's WebSocket session.
* `"brokerChannel"` -- for messages to the broker from within the application.
Every message sent from the application to the broker passes through this channel.

Messages on the `"clientInboundChannel"` can flow to annotated
methods for application handling (e.g. a stock trade execution request) or can
be forwarded to the broker (e.g. client subscribing for stock quotes).
The STOMP destination is used for simple prefix-based routing. For example
the "/app" prefix could route messages to annotated methods while the "/topic"
and "/queue" prefixes could route messages to the broker.

When a message-handling annotated method has a return type, its return
value is sent as the payload of a Spring `Message` to the `"brokerChannel"`.
The broker in turn broadcasts the message to clients. Sending a message
to a destination can also be done from anywhere in the application with
the help of a messaging template. For example, an HTTP POST handling method
can broadcast a message to connected clients, or a service component may
periodically broadcast stock quotes.

Below is a simple example to illustrate the flow of messages:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocketMessageBroker
	public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

		@Override
		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry.addEndpoint("/portfolio");
		}

		@Override
		public void configureMessageBroker(MessageBrokerRegistry registry) {
			registry.setApplicationDestinationPrefixes("/app");
			registry.enableSimpleBroker("/topic");
		}

	}

	@Controller
	public class GreetingController {

		@MessageMapping("/greeting") {
		public String handle(String greeting) {
			return "[" + getTimestamp() + ": " + greeting;
		}

	}

----

The following explains the message flow for the above example:

* WebSocket clients connect to the WebSocket endpoint at "/portfolio".
* Subscriptions to "/topic/greeting" pass through the "clientInboundChannel"
and are forwarded to the broker.
* Greetings sent to "/app/greeting" pass through the "clientInboundChannel"
and are forwarded to the `GreetingController`. The controller adds the current
time, and the return value is passed through the "brokerChannel" as a message
to "/topic/greeting" (destination is selected based on a convention but can be
overridden via `@SendTo`).
* The broker in turn broadcasts messages to subscribers, and they pass through
the `"clientOutboundChannel"`.

The next section provides more details on annotated methods including the
kinds of arguments and return values supported.



[[websocket-stomp-handle-annotations]]
==== Annotation Message Handling

The `@MessageMapping` annotation is supported on methods of `@Controller` classes.
It can be used for mapping methods to message destinations and can also be combined
with the type-level `@MessageMapping` for expressing shared mappings across all
annotated methods within a controller.

By default destination mappings are treated as Ant-style, slash-separated, path
patterns, e.g. "/foo*", "/foo/**". etc. They can also contain template variables,
e.g. "/foo/{id}" that can then be referenced via `@DestinationVariable`-annotated
method arguments.

[NOTE]
====
Applications can also use dot-separated destinations (vs slash).
See <<websocket-stomp-destination-separator>>.
====

The following method arguments are supported for `@MessageMapping` methods:

* `Message` method argument to get access to the complete message being processed.
* `@Payload`-annotated argument for access to the payload of a message, converted with
a `org.springframework.messaging.converter.MessageConverter`.
The presence of the annotation is not required since it is assumed by default.
Payload method arguments annotated with validation annotations (like `@Validated`) will
be subject to JSR-303 validation.
* `@Header`-annotated arguments for access to a specific header value along with
type conversion using an `org.springframework.core.convert.converter.Converter`
if necessary.
* `@Headers`-annotated method argument that must also be assignable to `java.util.Map`
for access to all headers in the message.
* `MessageHeaders` method argument for getting access to a map of all headers.
* `MessageHeaderAccessor`, `SimpMessageHeaderAccessor`, or `StompHeaderAccessor`
for access to headers via typed accessor methods.
* `@DestinationVariable`-annotated arguments for access to template
variables extracted from the message destination. Values will be converted to
the declared method argument type as necessary.
* `java.security.Principal` method arguments reflecting the user logged in at
the time of the WebSocket HTTP handshake.

The return value from an `@MessageMapping` method is converted with a
`org.springframework.messaging.converter.MessageConverter` and used as the body
of a new message that is then sent, by default, to the `"brokerChannel"` with
the same destination as the client message but using the prefix `"/topic"` by
default. An `@SendTo` message level annotation can be used to specify any
other destination instead.

An `@SubscribeMapping` annotation can also be used to map subscription requests
to `@Controller` methods. It is supported on the method level, but can also be
combined with a type level `@MessageMapping` annotation that expresses shared
mappings across all message handling methods within the same controller.

By default the return value from an `@SubscribeMapping` method is sent as a
message directly back to the connected client and does not pass through the
broker. This is useful for implementing request-reply message interactions; for
example, to fetch application data when the application UI is being initialized.
Or alternatively an `@SubscribeMapping` method can be annotated with `@SendTo`
in which case the resulting message is sent to the `"brokerChannel"` using
the specified target destination.


[[websocket-stomp-handle-send]]
==== Sending Messages

What if you want to send messages to connected clients from any part of the
application? Any application component can send messages to the `"brokerChannel"`.
The easiest way to do that is to have a `SimpMessagingTemplate` injected, and
use it to send messages. Typically it should be easy to have it injected by
type, for example:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Controller
	public class GreetingController {

		private SimpMessagingTemplate template;

		@Autowired
		public GreetingController(SimpMessagingTemplate template) {
			this.template = template;
		}

		@RequestMapping(value="/greetings", method=POST)
		public void greet(String greeting) {
			String text = "[" + getTimestamp() + "]:" + greeting;
			this.template.convertAndSend("/topic/greetings", text);
		}

	}
----

But it can also be qualified by its name "brokerMessagingTemplate" if another
bean of the same type exists.


[[websocket-stomp-handle-simple-broker]]
==== Simple Broker

The built-in, simple message broker handles subscription requests from clients,
stores them in memory, and broadcasts messages to connected clients with matching
destinations. The broker supports path-like destinations, including subscriptions
to Ant-style destination patterns.

[NOTE]
====
Applications can also use dot-separated destinations (vs slash).
See <<websocket-stomp-destination-separator>>.
====




[[websocket-stomp-handle-broker-relay]]
==== Full-Featured Broker

The simple broker is great for getting started but supports only a subset of
STOMP commands (e.g. no acks, receipts, etc.), relies on a simple message
sending loop, and is not suitable for clustering. As an alternative, applications
can upgrade to using a full-featured message broker.

Check the STOMP documentation for your message broker of choice (e.g.
http://www.rabbitmq.com/stomp.html[RabbitMQ],
http://activemq.apache.org/stomp.html[ActiveMQ], etc.), install the broker,
and run it with STOMP support enabled. Then enable the STOMP broker relay in the
Spring configuration instead of the simple broker.

Below is example configuration that enables a full-featured broker:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocketMessageBroker
	public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

		@Override
		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry.addEndpoint("/portfolio").withSockJS();
		}

		@Override
		public void configureMessageBroker(MessageBrokerRegistry registry) {
			registry.enableStompBrokerRelay("/topic", "/queue");
			registry.setApplicationDestinationPrefixes("/app");
		}

	}
----

XML configuration equivalent:

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			http://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			http://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:message-broker application-destination-prefix="/app">
			<websocket:stomp-endpoint path="/portfolio" />
				<websocket:sockjs/>
			</websocket:stomp-endpoint>
			<websocket:stomp-broker-relay prefix="/topic,/queue" />
		</websocket:message-broker>

	</beans>
----

The "STOMP broker relay" in the above configuration is a Spring
http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/messaging/MessageHandler.html[MessageHandler]
that handles messages by forwarding them to an external message broker.
To do so it establishes TCP connections to the broker, forwards all
messages to it, and then forwards all messages received
from the broker to clients through their WebSocket sessions. Essentially
it acts as a "relay" that forwards messages in both directions.

[NOTE]
====
Please add a dependency on `org.projectreactor:reactor-net` for TCP connection management.
====

Furthermore, application components (e.g. HTTP request handling methods,
business services, etc.) can also send messages to the broker relay, as described
in <<websocket-stomp-handle-send>>, in order to broadcast messages to
subscribed WebSocket clients.

In effect, the broker relay enables robust and scalable message broadcasting.

[[websocket-stomp-handle-broker-relay-configure]]
==== Connections To Full-Featured Broker

A STOMP broker relay maintains a single "system" TCP connection to the broker.
This connection is used for messages originating from the server-side application
only, not for receiving messages. You can configure the STOMP credentials
for this connection, i.e. the STOMP frame `login` and `passcode` headers. This
is exposed in both the XML namespace and the Java config as the
++systemLogin++/++systemPasscode++ properties with default values ++guest++/++guest++.

The STOMP broker relay also creates a separate TCP connection for every connected
WebSocket client. You can configure the STOMP credentials to use for all TCP
connections created on behalf of clients. This is exposed in both the XML namespace
and the Java config as the ++clientLogin++/++clientPasscode++ properties with default
values ++guest++/++guest++.

[NOTE]
====
The STOMP broker relay always sets the `login` and `passcode` headers on every `CONNECT`
frame that it forwards to the broker on behalf of clients. Therefore WebSocket clients
need not set those headers; they will be ignored. As the following section explains,
instead WebSocket clients should rely on HTTP authentication to protect the WebSocket
endpoint and establish the client identity.
====

The STOMP broker relay also sends and receives heartbeats to and from the message
broker over the "system" TCP connection. You can configure the intervals for sending
and receiving heartbeats (10 seconds each by default). If connectivity to the broker
is lost, the broker relay will continue to try to reconnect, every 5 seconds,
until it succeeds.

[NOTE]
====
A Spring bean can implement `ApplicationListener<BrokerAvailabilityEvent>` in order
to receive notifications when the "system" connection to the broker is lost and
re-established. For example a Stock Quote service broadcasting stock quotes can
stop trying to send messages when there is no active "system" connection.
====

The STOMP broker relay can also be configured with a `virtualHost` property.
The value of this property will be set as the `host` header of every `CONNECT` frame
and may be useful for example in a cloud environment where the actual host to which
the TCP connection is established is different from the host providing the
cloud-based STOMP service.

[[websocket-stomp-destination-separator]]
==== Using Dot as Separator in `@MessageMapping` Destinations

Although slash-separated path patterns are familiar to web developers, in messaging
it is common to use a "." as the separator, for example in the names of topics, queues,
exchanges, etc. Applications can also switch to using "." (dot) instead of "/" (slash)
as the separator in `@MessageMapping` mappings by configuring a custom `AntPathMatcher`.

In Java config:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
  @Configuration
  @EnableWebSocketMessageBroker
  public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer {

    // ...

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
      registry.enableStompBrokerRelay("/queue/", "/topic/");
      registry.setApplicationDestinationPrefixes("/app");
      registry.setPathMatcher(new AntPathMatcher("."));
    }

  }
----

In XML config:

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
  <beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
      http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans.xsd
      http://www.springframework.org/schema/websocket
      http://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:message-broker application-destination-prefix="/app" path-matcher="pathMatcher">
      <websocket:stomp-endpoint path="/stomp" />
      <websocket:simple-broker prefix="/topic, /queue"/>
    </websocket:message-broker>

    <bean id="pathMatcher" class="org.springframework.util.AntPathMatcher">
      <constructor-arg index="0" value="." />
    </bean>

  </beans>
----

And below is a simple example to illustrate a controller with "." separator:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
  @Controller
  @MessageMapping("foo")
  public class FooController {
    
    @MessageMapping("bar.{baz}")
    public void handleBaz(@DestinationVariable String baz) {
    }

  }
----

If the application prefix is set to "/app" then the foo method is effectively mapped to "/app/foo.bar.{baz}".




[[websocket-stomp-authentication]]
==== Authentication

In a WebSocket-style application it is often useful to know who sent a message.
Therefore some form of authentication is needed to establish the user identity
and associate it with the current session.

Existing Web applications already use HTTP based authentication.
For example Spring Security can secure the HTTP URLs of the application as usual.
Since a WebSocket session begins with an HTTP handshake, that means URLs mapped
to STOMP/WebSocket are already automatically protected and require authentication.
Moreover the page that opens the WebSocket connection is itself likely protected
and so by the time of the actual handshake, the user should have been authenticated.

When a WebSocket handshake is made and a new WebSocket session is created,
Spring's WebSocket support automatically propagates the `java.security.Principal`
from the HTTP request to the WebSocket session. After that every message flowing
through the application on that WebSocket session is enriched with
the user information. It's present in the message as a header.
Controller methods can access the current user by adding a method argument of
type `javax.security.Principal`.

Note that even though the STOMP `CONNECT` frame has "login" and "passcode" headers
that can be used for authentication, Spring's STOMP WebSocket support ignores them
and currently expects users to have been authenticated already via HTTP.

In some cases it may be useful to assign an identity to a WebSocket session even
when the user has not been formally authenticated. For example, a mobile app might
assign some identity to anonymous users, perhaps based on geographical location.
The do that currently, an application can sub-class `DefaultHandshakeHandler`
and override the `determineUser` method. The custom handshake handler can then
be plugged in (see examples in <<websocket-server-deployment>>).



[[websocket-stomp-user-destination]]
==== User Destinations

An application can send messages targeting a specific user, and Spring's STOMP support
recognizes destinations prefixed with `"/user/"` for this purpose.
For example, a client might subscribe to the destination `"/user/queue/position-updates"`.
This destination will be handled by the `UserDestinationMessageHandler` and
transformed into a destination unique to the user session,
e.g. `"/queue/position-updates-user123"`. This provides the convenience of subscribing
to a generically named destination while at the same time ensuring no collisions
with other users subscribing to the same destination so that each user can receive
unique stock position updates.

On the sending side messages can be sent to a destination such as
`"/user/{username}/queue/position-updates"`, which in turn will be translated
by the `UserDestinationMessageHandler` into one or more destinations, one for each
session associated with the user. This allows any component within the application to
send messages targeting a specific user without necessarily knowing anything more
than their name and the generic destination. This is also supported through an
annotation as well as a messaging template.

For example, a message-handling method can send messages to the user associated with
the message being handled through the `@SendToUser` annotation:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
@Controller
public class PortfolioController {

    @MessageMapping("/trade")
    @SendToUser("/queue/position-updates")
    public TradeResult executeTrade(Trade trade, Principal principal) {
        // ...
        return tradeResult;
    }
}
----

If the user has more than one session, by default all of the sessions subscribed
to the given destination are targeted. However sometimes, it may be necessary to
target only the session that sent the message being handled. This can be done by
setting the `broadcast` attribute to false, for example:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
@Controller
public class MyController {

    @MessageMapping("/action")
    public void handleAction() throws Exception{
        // raise MyBusinessException here
    }

    @MessageExceptionHandler
    @SendToUser(value="/queue/errors", broadcast=false)
    public ApplicationError handleException(MyBusinessException exception) {
        // ...
        return appError;
    }
}
----


[NOTE]
====
While user destinations generally imply an authenticated user, it isn't required
strictly. A WebSocket session that is not associated with an authenticated user
can subscribe to a user destination. In such cases the `@SendToUser` annotation
will behave exactly the same as with `broadcast=false`, i.e. targeting only the
session that sent the message being handled.
====

It is also possible to send a message to user destinations from any application
component by injecting the `SimpMessagingTemplate` created by the Java config or
XML namespace, for example (the bean name is `"brokerMessagingTemplate"` if required
for qualification with `@Qualifier`):

[source,java,indent=0]
[subs="verbatim,quotes"]
----
@Service
public class TradeServiceImpl implements TradeService {

	private final SimpMessagingTemplate messagingTemplate;

	@Autowired
	public TradeServiceImpl(SimpMessagingTemplate messagingTemplate) {
		this.messagingTemplate = messagingTemplate;
	}

	// ...

	public void afterTradeExecuted(Trade trade) {
		this.messagingTemplate.convertAndSendToUser(
				trade.getUserName(), "/queue/position-updates", trade.getResult());
	}
}
----

[NOTE]
====
When using user destinations with an external message broker, check the broker
documentation on how to manage inactive queues, so that when the user session is
over, all unique user queues are removed. For example, RabbitMQ creates auto-delete
queues when destinations like `/exchange/amq.direct/position-updates` are used.
So in that case the client could subscribe to `/user/exchange/amq.direct/position-updates`.
Similarly, ActiveMQ has
http://activemq.apache.org/delete-inactive-destinations.html[configuration options]
for purging inactive destinations.
====




[[websocket-stomp-appplication-context-events]]
==== Listening To ApplicationContext Events and Intercepting Messages

Several `ApplicationContext` events (listed below) are published and can be
received by implementing Spring's `ApplicationListener` interface.

* `BrokerAvailabilityEvent` -- indicates when the broker becomes available/unavailable.
While the "simple" broker becomes available immediately on startup and remains so while
the application is running, the STOMP "broker relay" may lose its connection
to the full featured broker, for example if the broker is restarted. The broker relay
has reconnect logic and will re-establish the "system" connection to the broker
when it comes back, hence this event is published whenever the state changes from connected
to disconnected and vice versa. Components using the `SimpMessagingTemplate` should
subscribe to this event and avoid sending messages at times when the broker is not
available. In any case they should be prepared to handle `MessageDeliveryException`
when sending a message.
* `SessionConnectEvent` -- published when a new STOMP CONNECT is received
indicating the start of a new client session. The event contains the message representing the
connect including the session id, user information (if any), and any custom headers the client
may have sent. This is useful for tracking client sessions. Components subscribed
to this event can wrap the contained message using `SimpMessageHeaderAccessor` or
`StompMessageHeaderAccessor`.
* `SessionConnectedEvent` -- published shortly after a `SessionConnectEvent` when the
broker has sent a STOMP CONNECTED frame in response to the CONNECT. At this point the
STOMP session can be considered fully established.
* `SessionSubscribeEvent` -- published when a new STOMP SUBSCRIBE is received.
* `SessionUnsubscribeEvent` -- published when a new STOMP UNSUBSCRIBE is received.
* `SessionDisconnectEvent` -- published when a STOMP session ends. The DISCONNECT may
have been sent from the client, or it may also be automatically generated when the
WebSocket session is closed. In some cases this event may be published more than once
per session. Components should be idempotent with regard to multiple disconnect events.

[NOTE]
====
When using a full-featured broker, the STOMP "broker relay" automatically reconnects the
"system" connection in case the broker becomes temporarily unavailable. Client connections
however are not automatically reconnected. Assuming heartbeats are enabled, the client
will typically notice the broker is not responding within 10 seconds. Clients need to
implement their own reconnect logic.
====

Furthermore, an application can directly intercept every incoming and outgoing message by
registering a `ChannelInterceptor` on the respective message channel. For example
to intercept inbound messages:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
  @Configuration
  @EnableWebSocketMessageBroker
  public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer {

    @Override
    public void configureClientInboundChannel(ChannelRegistration registration) {
      registration.setInterceptors(new MyChannelInterceptor());
    }
  }
----

A custom `ChannelInterceptor` can extend the empty method base class
`ChannelInterceptorAdapter` and use `StompHeaderAccessor` or `SimpMessageHeaderAccessor`
to access information about the message.

[source,java,indent=0]
[subs="verbatim,quotes"]
----
  public class MyChannelInterceptor extends ChannelInterceptorAdapter {

    @Override
    public Message<?> preSend(Message<?> message, MessageChannel channel) {
      StompHeaderAccessor accessor = StompHeaderAccessor.wrap(message);
      StompCommand command = accessor.getStompCommand();
      // ...
      return message;
    }
  }
----



[[websocket-stomp-websocket-scope]]
==== WebSocket Scope

Each WebSocket session has a map of attributes. The map is attached as a header to
inbound client messages and may be accessed from a controller method, for example:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
@Controller
public class MyController {

    @MessageMapping("/action")
    public void handle(SimpMessageHeaderAccessor headerAccessor) {
        Map<String, Object> attrs = headerAccessor.getSessionAttributes();
        // ...
    }
}
----

It is also possible to declare a Spring-managed bean in the `"websocket"` scope.
WebSocket-scoped beans can be injected into controllers and any channel interceptors
registered on the "clientInboundChannel". Those are typically singletons and live
longer than any individual WebSocket session. Therefore you will need to use a
scope proxy mode for WebSocket-scoped beans:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
@Component
@Scope(value="websocket", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class MyBean {

    @PostConstruct
    public void init() {
        // Invoked after dependencies injected
    }

    // ...

    @PreDestroy
    public void destroy() {
        // Invoked when the WebSocket session ends
    }
}

@Controller
public class MyController {

    private final MyBean myBean;

    @Autowired
    public MyController(MyBean myBean) {
        this.myBean = myBean;
    }

    @MessageMapping("/action")
    public void handle() {
        // this.myBean from the current WebSocket session
    }
}
----

As with any custom scope, Spring initializes a new `MyBean` instance the first
time it is accessed from the controller and stores the instance in the WebSocket
session attributes. The same instance is returned subsequently until the session
ends. WebSocket-scoped beans will have all Spring lifecycle methods invoked as
shown in the examples above.



[[websocket-stomp-configuration-performance]]
==== Configuration and Performance

There is no silver bullet when it comes to performance. Many factors may
affect it including the size of messages, the volume, whether application
methods perform work that requires blocking, as well as external factors
such as network speed and others. The goal of this section is to provide
an overview of the available configuration options along with some thoughts
on how to reason about scaling.

In a messaging application messages are passed through channels for asynchronous
executions backed by thread pools. Configuring such an application requires
good knowledge of the channels and the flow of messages. Therefore it is
recommended to review <<websocket-stomp-message-flow>>.

The obvious place to start is to configure the thread pools backing the
`"clientInboundChannel"` and the `"clientOutboundChannel"`. By default both
are configured at twice the number of available processors.

If the handling of messages in annotated methods is mainly CPU bound then the
number of threads for the `"clientInboundChannel"` should remain close to the
number of processors. If the work they do is more IO bound and requires blocking
or waiting on a database or other external system then the thread pool size
will need to be increased.

[NOTE]
====
`ThreadPoolExecutor` has 3 important properties. Those are the core and
the max thread pool size as well as the capacity for the queue to store
tasks for which there are no available threads.

A common point of confusion is that configuring the core pool size (e.g. 10)
and max pool size (e.g. 20) results in a thread pool with 10 to 20 threads.
In fact if the capacity is left at its default value of Integer.MAX_VALUE
then the thread pool will never increase beyond the core pool size since
all additional tasks will be queued.

Please review the Javadoc of `ThreadPoolExecutor` to learn how these
properties work and understand the various queuing strategies.
====

On the `"clientOutboundChannel"` side it is all about sending messages to WebSocket
clients. If clients are on a fast network then the number of threads should
remain close to the number of available processors. If they are slow or on
low bandwidth they will take longer to consume messages and put a burden on the
thread pool. Therefore increasing the thread pool size will be necessary.

While the workload for the "clientInboundChannel" is possible to predict --
after all it is based on what the application does -- how to configure the
"clientOutboundChannel" is harder as it is based on factors beyond
the control of the application. For this reason there are two additional
properties related to the sending of messages. Those are the `"sendTimeLimit"`
and the `"sendBufferSizeLimit"`. Those are used to configure how long a
send is allowed to take and how much data can be buffered when sending
messages to a client.

The general idea is that at any given time only a single thread may be used
to send to a client. All additional messages meanwhile get buffered and you
can use these properties to decide how long sending a message is allowed to
take and how much data can be buffered in the mean time. Please review the
Javadoc and documentation of the XML schema for this configuration for
important additional details.

Here is example configuration:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocketMessageBroker
	public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

		@Override
		public void configureWebSocketTransport(WebSocketTransportRegistration registration) {
			registration.setSendTimeLimit(15 * 1000).setSendBufferSizeLimit(512 * 1024);
		}

		// ...

	}
----

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			http://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			http://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:message-broker>
			<websocket:transport send-timeout="15000" send-buffer-size="524288" />
			<!-- ... -->
		</websocket:message-broker>

	</beans>
----

The WebSocket transport configuration shown above can also be used to configure the
maximum allowed size for incoming STOMP messages. Although in theory a WebSocket
message can be almost unlimited in size, in practice WebSocket servers impose
limits -- for example, 8K on Tomcat and 64K on Jetty. For this reason STOMP clients
such as stomp.js split larger STOMP messages at 16K boundaries and send them as
multiple WebSocket messages thus requiring the server to buffer and re-assemble.

Spring's STOMP over WebSocket support does this so applications can configure the
maximum size for STOMP messages irrespective of WebSocket server specific message
sizes. Do keep in mind that the WebSocket message size will be automatically
adjusted if necessary to ensure they can carry 16K WebSocket messages at a
minimum.

Here is example configuration:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocketMessageBroker
	public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

		@Override
		public void configureWebSocketTransport(WebSocketTransportRegistration registration) {
			registration.setMessageSizeLimit(128 * 1024);
		}

		// ...

	}
----

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			http://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			http://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:message-broker>
			<websocket:transport message-size="131072" />
			<!-- ... -->
		</websocket:message-broker>

	</beans>
----

An important point about scaling is using multiple application instances.
Currently it is not possible to do that with the simple broker.
However when using a full-featured broker such as RabbitMQ, each application
instance connects to the broker and messages broadcast from one application
instance can be broadcast through the broker to WebSocket clients connected
through any other application instances.



[[websocket-stomp-stats]]
==== Runtime Monitoring

When using `@EnableWebSocketMessageBroker` or `<websocket:message-broker>` key
infrastructure components automatically gather stats and counters that provide
important insight into the internal state of the application. The configuration
also declares a bean of type `WebSocketMessageBrokerStats` that gathers all
available information in one place and by default logs it at `INFO` level once
every 30 minutes. This bean can be exported to JMX through Spring's
`MBeanExporter` for viewing at runtime, for example through JDK's `jconsole`.
Below is a summary of the available information.

Client WebSocket Sessions::
    Current::: indicates how many client sessions there are
    currently with the count further broken down by WebSocket vs HTTP
    streaming and polling SockJS sessions.
    Total::: indicates how many total sessions have been established.
    Abnormally Closed:::
        Connect Failures:::: these are sessions that got established but were
        closed after not having received any messages within 60 seconds. This is
        usually an indication of proxy or network issues.
        Send Limit Exceeded:::: sessions closed after exceeding the configured send
        timeout or the send buffer limits which can occur with slow clients
        (see previous section).
        Transport Errors:::: sessions closed after a transport error such as
        failure to read or write to a WebSocket connection or
        HTTP request/response.
    STOMP Frames::: the total number of CONNECT, CONNECTED, and DISCONNECT frames
    processed indicating how many clients connected on the STOMP level. Note that
    the DISCONNECT count may be lower when sessions get closed abnormally or when
    clients close without sending a DISCONNECT frame.
STOMP Broker Relay::
    TCP Connections::: indicates how many TCP connections on behalf of client
    WebSocket sessions are established to the broker. This should be equal to the
    number of client WebSocket sessions + 1 additional shared "system" connection
    for sending messages from within the application.
    STOMP Frames::: the total number of CONNECT, CONNECTED, and DISCONNECT frames
    forwarded to or received from the broker on behalf of clients. Note that a
    DISCONNECT frame is sent to the broker regardless of how the client WebSocket
    session was closed. Therefore a lower DISCONNECT frame count is an indication
    that the broker is pro-actively closing connections, may be because of a
    heartbeat that didn't arrive in time, an invalid input frame, or other.
Client Inbound Channel:: stats from thread pool backing the "clientInboundChannel"
    providing insight into the health of incoming message processing. Tasks queueing
    up here is an indication the application may be too slow to handle messages.
    If there I/O bound tasks (e.g. slow database query, HTTP request to 3rd party
    REST API, etc) consider increasing the thread pool size.
Client Outbound Channel:: stats from the thread pool backing the "clientOutboundChannel"
    providing insight into the health of broadcasting messages to clients. Tasks
    queueing up here is an indication clients are too slow to consume messages.
    One way to address this is to increase the thread pool size to accommodate the
    number of concurrent slow clients expected. Another option is to reduce the
    send timeout and send buffer size limits (see the previous section).
SockJS Task Scheduler:: stats from thread pool of the SockJS task scheduler which
    is used to send heartbeats. Note that when heartbeats are negotiated on the
    STOMP level the SockJS heartbeats are disabled.

[[websocket-stomp-testing]]
==== Testing Annotated Controller Methods

There are two main approaches to testing applications using Spring's STOMP over
WebSocket support. The first is to write server-side tests verifying the functionality
of controllers and their annotated message handling methods. The second is to write
full end-to-end tests that involve running a client and a server.

The two approaches are not mutually exclusive. On the contrary each has a place
in an overall test strategy. Server-side tests are more focused and easier to write
and maintain. End-to-end integration tests on the other hand are more complete and
test much more, but they're also more involved to write and maintain.

The simplest form of server-side tests is to write controller unit tests. However
this is not useful enough since much of what a controller does depends on its
annotations. Pure unit tests simply can't test that.

Ideally controllers under test should be invoked as they are at runtime, much like
the approach to testing controllers handling HTTP requests using the Spring MVC Test
framework. i.e. without running a Servlet container but relying on the Spring Framework
to invoke the annotated controllers. Just like with Spring MVC Test here there are two
two possible alternatives, either using a "context-based" or "standalone" setup:

1. Load the actual Spring configuration with the help of the
Spring TestContext framework, inject "clientInboundChannel" as a test field, and
use it to send messages to be handled by controller methods.

2. Manually set up the minimum Spring framework infrastructure required to invoke
controllers (namely the `SimpAnnotationMethodMessageHandler`) and pass messages for
controllers directly to it.

Both of these setup scenarios are demonstrated in the
https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web[tests for the stock portfolio]
sample application.

The second approach is to create end-to-end integration tests. For that you will need
to run a WebSocket server in embedded mode and connect to it as a WebSocket client
sending WebSocket messages containing STOMP frames.
The https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web[tests for the stock portfolio]
sample application also demonstrates this approach using Tomcat as the embedded
WebSocket server and a simple STOMP client for test purposes.
